### 1. 题目链接

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)


**如下图所示：**

![Alt text](./05%20imgae/image.png)


### 2. 解法（模拟）

**算法思路：**

本题的目标非常清晰易懂，不涉及复杂的算法，只是实现过程中需要考虑的细节比较多。

我们可以把链表按 k 个为一组进行分组，组内进行反转，并且记录反转后的头尾结点，使其可以和前、后连接起来。思路比较简单，但是实现起来是比较复杂的。

我们可以先求出一共需要逆序多少组（假设逆序 n 组），然后重复 n 次长度为 k 的链表的逆序即可。

**如下图所示：**

![Alt text](./05%20imgae/image-1.png)


### 3. 算法代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 节点存储的值
 *     ListNode *next;   // 指向下一个节点的指针
 *     ListNode() : val(0), next(nullptr) {}  // 默认构造函数
 *     ListNode(int x) : val(x), next(nullptr) {}  // 带值构造函数
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}  // 带值和下一个节点的构造函数
 * };
 */
class Solution 
{
public:
    // 核心功能：每k个节点一组翻转链表，最后不足k个的保持原顺序
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        // 1. 第一步：计算链表总节点数，确定需要完整翻转的组数（n = 总节点数 / k）
        int n = 0;                  // 用于统计链表总节点数
        ListNode* cur = head;       // 遍历指针，初始指向链表头
        while (cur)                 // 遍历整个链表统计节点数
        {
            cur = cur->next;        // 指针后移
            n++;                    // 节点数加1
        }
        n /= k;                     // 计算需要翻转的组数（比如总5个节点、k=2时，n=2组）

        // 2. 第二步：创建虚拟头节点（简化链表头操作，避免边界处理）
        ListNode* newHead = new ListNode(0);  // 虚拟头节点，next最终指向结果链表头
        ListNode* prev = newHead;             // 前驱指针，初始指向虚拟头，用于衔接翻转后的子链表
        cur = head;                           // 重置遍历指针，回到原链表头

        // 3. 第三步：逐组翻转（共n组，每组k个节点）
        for (int i = 0; i < n; i ++)
        {
            ListNode* tmp = cur;    // 保存当前组的第一个节点（翻转后会变成该组最后一个节点，用于衔接下一组）
            // 对当前组的k个节点进行逐个翻转（头插法）
            for (int j = 0; j < k; j++)
            {
                ListNode* next = cur->next;   // 暂存当前节点的下一个节点（防止链表断裂）
                cur->next = prev->next;       // 翻转当前节点的next指针，指向前驱的下一个节点
                prev->next = cur;             // 前驱的next指向当前节点（将当前节点插入到前驱之后）
                cur = next;                   // 遍历指针后移，处理下一个节点
            }
            prev = tmp;             // 更新前驱指针为当前组翻转后的最后一个节点（即原组第一个节点）
        }

        // 4. 第四步：衔接最后不足k个的剩余节点（保持原顺序）
        prev->next = cur;           // 最后一组翻转后的尾节点，指向剩余未翻转的节点

        // 5. 第五步：释放虚拟头节点，返回结果链表的真实头节点
        cur = newHead->next;        // 保存结果链表的真实头节点
        delete newHead;             // 释放虚拟头节点内存，避免内存泄漏
        return cur;                 // 返回修改后的链表头
    }
};
```

**关键注释补充说明:**
- **虚拟头节点（newHead）**：这是链表操作的常用技巧，避免处理「链表头节点无前驱」的边界情况，让翻转逻辑统一。
- **头插法翻转**：每组k个节点的翻转采用「头插法」—— 把当前节点逐个插入到`prev->next`位置，最终实现k个节点的逆序。
- **tmp指针的作用**：每组翻转前保存当前组第一个节点，翻转后该节点会变成组内最后一个节点，用于衔接下一组或剩余节点。
- **内存释放**：最后删除虚拟头节点，避免内存泄漏（虽然LeetCode评测不强制，但这是良好的编程习惯）。

**总结:**
- 核心逻辑分为三步：统计组数 → 逐组头插法翻转 → 衔接剩余节点；
- 虚拟头节点是简化链表头操作的关键，避免边界条件处理复杂；
- 头插法是实现局部链表翻转的核心，通过调整`next`指针完成节点顺序反转，而非修改节点值。


