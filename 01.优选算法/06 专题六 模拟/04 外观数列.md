### 1. 题目链接

[38. 外观数列](https://leetcode.cn/problems/count-and-say/description/)

**如图所示：**

![Alt text](./04%20image/image.png)


### 2. 解法（模拟 + 双指针）

**算法思路：**
- 所谓「外观数列」，其实只是依次统计字符串中连续且相同的字符的个数。依照题意，依次模拟即可。


**如下图所示：**

![Alt text](./04%20image/image-1.png)


### 3. 算法代码


```cpp
class Solution {
public:
    string countAndSay(int n) {
        // 初始化第1项的外观数列，递归的起始值
        string ret = "1";
        // 从第2项开始，循环生成到第n项（共需要生成n-1次）
        for (int i = 1; i < n; i ++)
        {
            // 临时字符串，存储当前项的生成结果
            string tmp;
            // 获取上一项字符串的长度，用于遍历边界
            int len = ret.size();
            // 双指针：left标记当前连续字符的起始位置，right用于遍历相同字符
            for (int left = 0, right = 0; right < len; )
            {
                // 找到所有和ret[left]连续相同的字符，right右移至不同字符处
                while (right < len && ret[left] == ret[right])
                    right++;
                // 拼接：连续字符的个数(right-left) + 该字符，加入临时结果
                tmp += to_string(right - left) + ret[left];
                // 将left移动到right的位置，开始处理下一组连续字符
                left = right;
            }
            // 将临时结果赋值给ret，作为下一次循环的上一项字符串
            ret = tmp;
        }
        // 循环结束后，ret即为第n项的外观数列
        return ret;
    }
};
```

**注释说明补充：**
- 核心思路采用 **迭代+双指针**，比纯递归更高效（避免递归的栈开销），也是外观数列的最优解法之一；
- 双指针的作用是 **快速统计连续相同字符的个数**：`left`固定起始位，`right`探底相同字符的结束位，差值即为个数；
- `to_string(right - left)` 将数字转为字符串，满足外观数列**“数个数+说字符”**的核心规则。

**代码执行流程示例（n=4）：**
```
n=1: ret = "1"（初始值）

i=1（生成n=2）：遍历"1" → 1个1 → tmp="11" → ret="11"

i=2（生成n=3）：遍历"11" → 2个1 → tmp="21" → ret="21"

i=3（生成n=4）：遍历"21" → 1个2 + 1个1 → tmp="1211" → ret="1211"

返回ret="1211"，与示例一致
```

