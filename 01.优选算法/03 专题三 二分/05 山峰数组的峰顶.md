### 1. 题目链接

[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/)


### 2. 解法一（暴力查找）

**算法思路：**

峰顶的特点：比两侧的元素都要大。

因此，我们可以遍历数组内的每一个元素，找到某一个元素比两边的元素大即可。

**代码实现：**
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();

        // 遍历数组内每⼀个元素，直到找到峰顶
        for (int i = 1; i < n -1; i ++)
        {
            // 峰顶满足的条件
            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1])
                return i;
        }
        // 为了处理 oj 需要控制所有路径都有返回值
        return -1;
    }
};
```


### 3. 解法二（二分查找）

**算法思路：**

a. 分析峰顶位置的数据特点，以及山峰两旁的数据的特点：
   - 峰顶数据特点：`arr[i] > arr[i - 1] && arr[i] > arr[i + 1]`；
   - 峰顶左边的数据特点：`arr[i] > arr[i - 1] && arr[i] < arr[i + 1]`，也就是呈现上升趋势；
   - 峰顶右边的数据特点：`arr[i] < arr[i - 1] && arr[i] > arr[i + 1]`，也就是呈现下降趋势。

b. 因此，根据 `mid` 位置的信息，我们可以分为下面三种情况：
   - 如果 `mid` 位置呈现上升趋势，说明我们接下来要在 `[mid + 1, right]` 区间继续搜索；
   - 如果 `mid` 位置呈现下降趋势，说明我们接下来要在 `[left, mid - 1]` 区间搜索；
   - 如果 `mid` 位置就是山峰，直接返回结果。


**如图所示：**

![Alt text](./05%20image/image.png)


**代码如下：**
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        // 数组中的第一个位置和最后一个位置一定不会是峰值
        int left = 1, right = arr.size() - 2;  // 定义左右边界，确保在峰值元素的范围内查找
        
        while (left < right) {
            // 计算中间位置，选择向右偏移，这样可以避免死循环
            int mid = left + (right - left + 1) / 2;
            
            // 如果中间元素大于前一个元素，说明当前元素可能是峰值的左侧
            if (arr[mid] > arr[mid - 1])
                left = mid;  // 向右收缩边界
            
            // 如果中间元素小于前一个元素，说明当前元素位于下降段
            else if (arr[mid] < arr[mid - 1])
                right = mid - 1;  // 向左收缩边界
            
            // 由于峰值元素只有一个，若中间元素等于前一个元素，跳出循环
            else    
                break;
        }
        // 最后 left 指向峰值元素的下标
        return left;
    }
};

```