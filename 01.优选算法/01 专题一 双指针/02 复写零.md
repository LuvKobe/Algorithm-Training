

### 1. 题目链接

[1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/description/)


### 2. 解法

**算法思路：**

- 如果「从前向后」进⾏原地复写操作的话，由于 `0`` 的出现会复写两次，导致没有复写的数「被覆盖掉」。因此我们选择「从后往前」的复写策略。
- 但是「从后向前」复写的时候，我们需要找到「最后⼀个复写的数」，因此我们的⼤体流程分两步：
    - 先找到最后⼀个复写的数；
    - 然后从后向前进⾏复写操作。


**算法流程：**

a. 初始化两个指针 `cur = 0`， `dest = -1`；
b. 找到最后⼀个复写的数：
- 当 `cur < n` 的时候，⼀直执⾏下⾯循环：
    - 判断 `cur` 位置的元素:
        - 如果是 `0` 的话，`dest` 往后移动两位；
        - 否则，`dest` 往后移动一位。
    - 判断 `dest` 时候已经到结束位置，如果结束就终⽌循环；
    - 如果没有结束，`cur++`，继续判断。

c. 判断 `dest` 是否越界到 `n` 的位置：
- 如果越界，执⾏下⾯三步：
    - `n- 1` 位置的值修改成 `0`；
    - `cur` 向前移动⼀步；
    - `dest` 向前移动两步；

d. 从 `cur` 位置开始往前遍历原数组，依次还原出复写后的结果数组：
- 判断 `cur` 位置的值：
    - 如果是 `0` ： `dest` 以及 `dest - 1` 位置修改成 `0` ，`dest -= 2` ； 
    - 如果非零：`dest` 位置修改成 `cur` 指向的元素值，`dest -= 1`；
- `cur--`，复写下一个位置。



**总结：**
- 先找到最后一个 "复写" 的数：
    - 1. 先判断 `cur` 位置的值；
    - 2. 决定 `dest` 向后移动一步或者两步；
    - 3. 判断一下 `dest` 是否已经到结束位置；
    - 4. `cur++`；
- 从后向前的完成复写操作；


### 3. 算法流程图

初始时：
![Alt text](./02%20image/image.png)

第一步：
![Alt text](./02%20image/image-1.png)

第二步：
![Alt text](./02%20image/image-2.png)

第三步：
![Alt text](./02%20image/image-3.png)

第四步：
![Alt text](./02%20image/image-4.png)

第五步：
![Alt text](./02%20image/image-5.png)

第六步：
![Alt text](./02%20image/image-6.png)

此时 `cur` 指向的正好是要复写的最后一个数，而 `dest` 指向的是「最后⼀个复写的数」要填的位置

接着，从后向前的完成复写操作。


### 4. 算法代码

C++ 代码
```cpp
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
         // 1. 先找到最后⼀个数
        int cur = 0, dest = -1, len = arr.size();
        while (cur < len)
        {
            if (arr[cur] == 0)
            {
                dest += 2;
            }
            else 
            {
                dest += 1;
            }

            // 先判断dest是否已经走到结束位置, 再决定cur要不要往后走
            if (dest >= len - 1)
                break;
            
            //
            cur ++;
        }

         // 2. 处理⼀下边界情况
        if (dest == len)
        {
            arr[len - 1] = 0;
            cur--;
            dest -= 2;
        }

        // 3. 从后向前完成复写操作
        while (cur >= 0)
        {
            if (arr[cur] == 0)
            {
                arr[dest] = 0;
                arr[dest - 1] = 0;
                dest -= 2;
                cur --;
            }
            else 
            {
                arr[dest] = arr[cur];
                dest--;
                cur--;
            }
        }
    }
};
```

代码优化
```cpp
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
         // 1. 先找到最后⼀个数
        int cur = 0, dest = -1, n = arr.size();
        while (cur < n)
        {
            if (arr[cur]) // cur指向的元素不为0
                dest += 1;
            else 
                dest += 2;

            // 先判断dest是否已经走到结束位置, 再决定cur要不要往后走
            if (dest >= n - 1)
                break;
            
            //
            cur ++;
        }

         // 2. 处理⼀下边界情况
        if (dest == n)
        {
            arr[n - 1] = 0;
            cur --;
            dest -= 2;
        }

        // 3. 从后向前完成复写操作
        while (cur >= 0)
        {
            if (arr[cur]) // cur指向的元素不为0
            {
                arr[dest --] = arr[cur --];
            }
            else 
            {
                arr[dest --] = 0;
                arr[dest --] = 0;
                cur --;
            }
        }
    }
};
```