### 1. 题目链接

[15. 三数之和](https://leetcode.cn/problems/3sum/description/)


### 2. 解法（排序 + 双指针）

**算法思路：**

本题与两数之和类似，是非常经典的面试题。

与两数之和稍微不同的是，题目中要求找到所有「不重复」的三元组。那我们可以利用在「两数之和」那里用的双指针思想，来对我们的暴力枚举做优化：
- 先排序；
- 然后固定一个数 `a`；
- 在这个数后面的区间内，使用「双指针算法」快速找到两个数之和等于 `-a` 即可。


但是要注意的是，这道题里面需要有「去重」操作
- 找到一个结果之后，`left` 和 `right` 指针要「跳过重复」的元素；
- 当使用完一次双指针算法之后，固定的 `a` 也要「跳过重复」的元素。


**思考图：**

![Alt text](./03%20image/image.png)

**C++算法代码：**
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 1. 定义返回容器
        vector<vector<int>> ret;

        // 2. 先排序
        sort(nums.begin(), nums.end());

        // 3. 利用双指针来解决问题
        int n = nums.size();
        for (int i = 0; i < n; )    // 先固定一个数
        {
            if (nums[i] > 0)    // 固定的数如果是正数, 那么直接终止循环
                break;
            
            // 定义双指针
            int left = i + 1, right = n - 1, target = -nums[i];  // target 为固定数的相反数
            while (left < right)    // 两个指针开始在区间内查找
            {
                int sum = nums[left] + nums[right];
                if (sum > target)
                {
                    right--;
                }
                else if (sum < target)
                {
                    left++;
                }
                else 
                {
                    ret.push_back({nums[i], nums[left], nums[right]});
                    left++, right--;

                    // 开始去重left和right
                    while (left < right && nums[left] == nums[left - 1]) // left如何和它前一个数相等, 那么就继续++
                        left++;
                    while (left < right && nums[right] == nums[right + 1]) // right如何和它后一个数相等, 那么就继续--
                        right--;
                }
            }

            // 开始去重固定的数i
            i++;
            while (i < n && nums[i] == nums[i - 1])
                i++;
        }
        return ret;
    }
};
```