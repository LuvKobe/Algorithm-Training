### 1. 题目链接

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/description/)


### 2. 解法（滑动窗口）

**算法思路:**
研究的对象是一段连续的区间，可以使用「滑动窗口」思想来解决问题。

让滑动窗口满足：窗口内水果的种类只有两种。


**做法:**
右端水果进入窗口的时候，用哈希表统计这个水果的频次。这个水果进来后，判断哈希表的大小：
- 如果大小超过 `2`：说明窗口内水果种类超过了两种。那么就从左侧开始依次将水果划出窗口，直到哈希表的大小小于等于 `2`，然后更新结果；
- 如果没有超过 `2`，说明当前窗口内水果的种类不超过两种，直接更新结果 `ret`。


**算法流程:**
- 初始化哈希表 `hash` 来统计窗口内水果的种类和数量；
- 初始化变量：左右指针 `left = 0`，`right = 0`，记录结果的变量 `ret = 0`；
- 当 `right` 小于数组大小的时候，一直执行下列循环：
   - 将当前水果放入哈希表中；
   - 判断当前水果进来后，哈希表的大小：
       - 如果超过 `2`：
         - 将左侧元素滑出窗口，并且在哈希表中将该元素的频次减一；
         - 如果这个元素的频次减一之后变成了 `0`，就把该元素从哈希表中删除；
         - 重复上述两个过程，直到哈希表中的大小不超过 `2`；
   - 更新结果 `ret`；
   - `right++`，让下一个元素进入窗口；
- 循环结束后，`ret`存的就是最终结果。

**如下图所示：**

![Alt text](./05%20image/image.png)


### 3. 算法流程

第一次：

![Alt text](./05%20image/image-1.png)

第二次：

![Alt text](./05%20image/image-2.png)

第三次：

![Alt text](./05%20image/image-3.png)


第四次：

![Alt text](./05%20image/image-4.png)

第五次：

![Alt text](./05%20image/image-5.png)


### 4. 算法代码

**使用 STL 容器：**

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        // hash 用来统计当前滑动窗口内每种水果的出现次数
        // 由于只能有两种水果，这里维护窗口内的水果种类数 <= 2
        unordered_map<int, int> hash;

        int n = fruits.size();
        int len = -1;  // 最终结果：窗口最大长度，也就是能摘取的最多水果数

        // 滑动窗口左右指针
        for (int left = 0, right = 0; right < n; right++)
        {
            // 1. 扩展右边界，将 fruits[right] 加入窗口
            hash[ fruits[right] ]++;

            // 2. 如果窗口内出现了超过两种水果，需要缩小窗口（移动 left）
            while (hash.size() > 2)
            {
                // 左边界的水果数量减少
                hash[ fruits[left] ]--;

                // 如果某种水果数量变为 0，则从 map 中移除
                if (hash[ fruits[left] ] == 0)
                    hash.erase( fruits[left] );

                left++;  // 收缩左边界
            }

            // 3. 此时窗口内最多两种水果，是合法的
            // 更新最大长度
            len = max(len, right - left + 1);
        }

        return len;
    }
};
```

**使用数组模拟哈希表：**
```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        // 题目范围说明：
        // 0 <= fruits[i] < fruits.length <= 100000
        // 因此可以直接开一个大小为 100001 的数组来统计每种水果的出现次数
        int hash[100001] = { 0 };

        int n = fruits.size();
        int len = -1;      // 保存最大窗口长度（最大能采到的水果数）
        int kinds = 0;     // 记录窗口内的水果种类数量（最多允许为 2）

        // 滑动窗口左右指针
        for (int left = 0, right = 0; right < n; right++)
        {
            // ---- 右侧加入一个水果 ----
            // 如果该水果原来次数为 0，说明是一种新的水果种类
            if (hash[ fruits[right] ] == 0)    
                kinds++;

            // 增加该水果的数量
            hash[ fruits[right] ]++;
            
            // ---- 若水果种类超过 2，需要让左边界右移（缩小窗口） ----
            while (kinds > 2)
            {
                // 左边界水果数量减少
                hash[ fruits[left] ]--;

                // 若该水果数量变为 0，则一种水果种类被移除
                if (hash[ fruits[left] ] == 0)
                    kinds--;

                // 左指针右移
                left++;
            }

            // ---- 此时窗口合法（只有 1 或 2 种水果） ----
            // 更新最大窗口宽度
            len = max(len, right - left + 1);
        }

        return len;
    }
};
```