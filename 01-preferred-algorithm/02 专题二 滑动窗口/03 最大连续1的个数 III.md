### 1. 题目链接

[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)

### 2. 解法一（暴力求解 - 会超时）

**如下图所示：**

![Alt text](./03%20image/image.png)


**算法代码：**
```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int len = 0; // 记录结果

        // 暴力枚举：找出最长的子数组，使其中0的个数不超过k个
        for (int i = 0; i < n; i ++)
        {
            int cnt = 0; // 统计0的个数
            int j;
            for (j = i; j < n; j ++)
            {
                if (0 == nums[j])
                {
                    cnt++;
                    if (cnt > k) // 关键点
                    {
                        break;
                    }
                }
            }
            // j 此时要么是 n（正常结束），要么是第一个让 cnt>k 的位置
            len = max(len, j - i);
        }
        return len;
    }
};
```

### 3. 解法二（滑动窗口）

**算法思路：**

不要去想怎么翻转，不要把问题想的很复杂，这道题的结果无非就是一段连续的 `1` 中间塞了 `k` 个 `0` 嘛。

因此，我们可以把问题转化成：求数组中一段最长的连续区间，要求这段区间内 `0` 的个数不超过 `k` 个。

既然是连续区间，可以考虑使用「滑动窗口」来解决问题。

**算法流程：**

- 初始化一个大小为 `2` 的数组就可以当做哈希表 `hash` 了；初始化一些变量 `left = 0`, `right = 0`, `ret = 0`；

- 当 `right` 小于数组大小的时候，一直执行下列循环：
    - 让当前元素进入窗口，顺便统计到哈希表中；
    - 检查 `0` 的个数是否超标：
        - 如果超标，依次让左侧元素滑出窗口，顺便更新哈希表的值，直到 `0` 的个数恢复正常；
    - 程序到这里，说明窗口内元素是符合要求的，更新结果；
    - `right++`，处理下一个元素；

- 循环结束后， `ret` 存的就是最终结果。


**如下图所示：**

![Alt text](./03%20image/image-1.png)

**算法代码：**
```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int len = 0;     // 最长连续 1 的长度
        int zeroCnt = 0; // 当前窗口中 0 的个数

        // 使用滑动窗口：left 是窗口左边界，right 是窗口右边界
        for (int left = 0, right = 0; right < n; right++)
        {
            // 1. 进窗口:
            // 把 nums[right] 加入窗口
            if (0 == nums[right]) {
                zeroCnt++; // 记录当前窗口中 0 的个数
            }
            // 2. 做判断: 
            // 如果窗口中 0 的数量超过了 k，就不断收缩窗口左边界
            while (zeroCnt > k)
            {
                // nums[left] 要被移出窗口
                if (nums[left] == 0) {
                    zeroCnt--;  // 移出 0，需要减少计数
                }
                left++; // 收缩窗口
            }
            // 3. 更新结果
            // 到这里说明窗口内最多只有 k 个 0，是合法的
            // 使用当前窗口长度更新最大值
            len = max(len, right - left + 1);
        }
        return len;
    }
};
```