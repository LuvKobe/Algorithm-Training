### 双指针

常⻅的双指针有两种形式，⼀种是对撞指针，⼀种是左右指针。

对撞指针：⼀般⽤于顺序结构中，也称左右指针。
- 对撞指针从两端向中间移动。⼀个指针从最左端开始，另⼀个从最右端开始，然后逐渐往中间逼近。
- 对撞指针的终⽌条件⼀般是两个指针相遇或者错开（也可能在循环内部找到结果直接跳出循环），也就是：
    - `left == right `（两个指针指向同⼀个位置）
    - `left > right`（两个指针错开）

快慢指针：⼜称为龟兔赛跑算法，其基本思想就是使⽤两个移动速度不同的指针在数组或链表等序列结构上移动。

这种⽅法对于处理环形链表或数组⾮常有⽤。

其实不单单是环形链表或者是数组，如果我们要研究的问题出现循环往复的情况时，均可考虑使⽤快慢指针的思想。

快慢指针的实现⽅式有很多种，最常⽤的⼀种就是：
- 在⼀次循环中，每次让慢的指针向后移动⼀位，⽽快的指针往后移动两位，实现⼀快⼀慢。



### 1. 题目链接

[283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)


### 2. 解法

采用快排的思想，数组划分区间 - 数组分两块。

**算法思路：**
- 在本题中，我们可以⽤⼀个 `cur` 指针来扫描整个数组，另⼀个 `dest` 指针⽤来记录⾮零数序列的最后⼀个位置。根据 `cur` 在扫描的过程中，遇到的不同情况，分类处理，实现数组的划分。

在 `cur` 遍历期间，使 `[0, dest]` 的元素全部都是⾮零元素，`[dest + 1, cur - 1]` 的元素全是零。

**算法流程：**

a. 初始化 `cur = 0`（用来遍历数组） ，`dest = -1` （指向⾮零元素序列的最后⼀个位置。因为刚开始我们不知道最后⼀个⾮零元素在什么位置，因此初始化为 `-1`）


b. `cur` 依次往后遍历每个元素，遍历到的元素会有下⾯两种情况：
- 遇到的元素是 `0`，`cur` 直接 `++`，因为我们的⽬标是让 `[dest + 1, cur - 1]` 内的元素全都是零，因此当 `cur` 遇到 `0` 的时候，直接 `++`，就可以让 `0` 在 `cur - 1` 的位置上，从而在 `[dest + 1, cur - 1]` 内；
- 遇到的元素不是 `0`，`dest++`，并且交换 `cur` 位置和 `dest` 位置的元素，之后让 `cur++`，扫描下一个元素。
    - 因为 `dest` 指向的位置是⾮零元素区间的最后⼀个位置，如果扫描到⼀个新的⾮零元素，那么它的位置应该在 `dest + 1` 的位置上，因此 `dest` 先⾃增 `1` ； 
    -  `dest++` 之后，指向的元素就是 `0` 元素（因为⾮零元素区间末尾的后⼀个元素就是 `0`），因此可以交换到 `cur` 所处的位置上，实现 `[0, dest]` 的元素全部都是非零元素，`[dest + 1, cur - 1]` 的元素全是零。


### 3. 算法流程图

初始化如下：
![Alt text](./01%20image/image.png)

第一次：
![Alt text](./01%20image/image-6.png)

第二次：
![Alt text](./01%20image/image-1.png)

第三次：
![Alt text](./01%20image/image-7.png)

第四次：
![Alt text](./01%20image/image-4.png)

第五次：
![Alt text](./01%20image/image-8.png)

第六次：
![Alt text](./01%20image/image-9.png)

### 4. 算法代码

C++ 代码
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int dest = -1, cur = 0;
        int len = nums.size();
        for ( ; cur < len; cur ++)
        {
            if (nums[cur] != 0) // 处理⾮零元素
            {
                dest++;
                swap(nums[dest], nums[cur]);
            }
        }
    }
};
```

代码优化
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int len = nums.size();
        for (int dest = -1, cur = 0; cur < len; cur ++)
        {
            if (nums[cur]) // 处理⾮零元素
            {
                swap(nums[++dest], nums[cur]);
            }
        }
    }
};
```

### 4. 算法总结
这个⽅法是往后我们学习「快排算法」的时候，「数据划分」过程的重要⼀步。

如果将快排算法拆解的话，这⼀段⼩代码就是实现快排算法的「核⼼步骤」。