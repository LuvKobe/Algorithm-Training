### 1. 题目链接

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

### 2. 解法一（暴力枚举 + 哈希表）

**如下图所示：**

![Alt text](./08%20image/image.png)


### 3. 解法二（滑动窗口 + 哈希表）

**算法思路：**
- 研究对象是连续的区间，因此可以尝试使用滑动窗口的思想来解决。
- 如何判断当前窗口内的所有字符是符合要求的呢？

我们可以使用两个哈希表，其中一个将目标串的信息统计起来，另一个哈希表动态的维护窗口内字符串的信息。

当动态哈希表中包含目标串中所有的字符，并且对应的个数都不小于目标串的哈希表中各个字符的个数，那么当前的窗口就是一种可行的方案。

**算法流程:**
- 定义两个全局的哈希表: `1` 号哈希表 `hash1` 用来记录子串的信息，`2` 号哈希表 `hash2` 用来记录目标串 `t` 的信息；

- 实现一个接口函数，判断当前窗口是否满足要求:
    - 遍历两个哈希表中对应位置的元素:
        - 如果 `t` 中某个字符的数量大于窗口中字符的数量，也就是 `2` 号哈希表某个位置大于 `1` 号哈希表。说明不匹配，返回 `false`；
        - 如果全都匹配，返回 `true`。

**主函数中:**
- 先将 `t` 的信息放入 `2` 号哈希表中；

- 初始化一些变量: 左右指针: `left = 0，right = 0`；目标子串的长度: `len = INT_MAX`；目标子串的起始位置: `index`；（通过目标子串的起始位置和长度，我们就能找到结果）

- 当 `right` 小于字符串 `s` 的长度时，一直下列循环:
    - 将当前遍历到的元素扔进 `1` 号哈希表中；
    - 检测当前窗口是否满足条件:
        - 如果满足条件:
            - 判断当前窗口是否变小。如果变小: 更新长度 `len`，以及字符串的起始位置 `index`；
            - 判断完毕后，将左侧元素滑出窗口，顺便更新 `1` 号哈希表；
            - 重复上面两个过程，直到窗口不满足条件；
    - `right++`，遍历下一个元素；

- 判断 `len` 的长度是否等于 `INT_MAX`:
    - 如果相等，说明没有匹配，返回空串；
    - 如果不相等，说明匹配，返回 `s` 中从 `index` 位置往后 `len` 长度的字符串。


**如下图所示：**

![Alt text](./08%20image/image-1.png)


**算法代码：**
```cpp
class Solution {
public:
    // 功能：判断当前窗口 hashS 是否已经“覆盖”了模式串 t 的所有字符
    // 思路：逐个字符比较两个数组对应位置的值，
    //      只要有一个字符在窗口中的数量小于 t 中需要的数量，就说明还没覆盖完全。
    bool check(const int hashS[], const int hashT[])
    {
        // ASCII 字符总数在本题中限定为 128（足够覆盖常见字符）
        for (int i = 0; i < 128; ++i)
        {
            // 如果 s 当前窗口中字符 i 的数量 < t 中所需的数量
            // 说明当前窗口还不满足“覆盖 t 中所有字符”的条件
            if (hashS[i] < hashT[i])
                return false;
        }
        // 能走到这里，说明所有字符 i 都满足 hashS[i] >= hashT[i]
        // 即当前窗口已经完全覆盖 t
        return true;
    }

    string minWindow(string s, string t) {
        // 统计字符串 t 中每一个字符的频次，存储到 hashT 中
        // hashT[ch] 表示：t 中字符 ch 需要的数量
        int hashT[128] = { 0 };
        for (const auto &ch : t) hashT[ch]++;
        
        int n = s.size(); // s 的长度
        int m = t.size(); // t 的长度

        // 如果 t 比 s 还长，那肯定不可能存在一个子串覆盖 t
        if (m > n) return "";

        // hashS 用来统计当前滑动窗口 [left, right] 内每个字符出现的次数
        // hashS[ch] 表示：s 当前窗口中字符 ch 的数量
        int hashS[128] = { 0 };

        int index = 0;          // 记录最小覆盖子串的起始下标
        int len = INT_MAX;      // 记录最小覆盖子串的长度，初始化为无穷大

        // 经典滑动窗口双指针：left 表示窗口左边界，right 表示窗口右边界
        for (int left = 0, right = 0; right < n; ++right)
        {
            // 右指针右移，新字符进窗口
            char in = s[right];
            hashS[in]++;  // 更新窗口内频次数组

            // 当当前窗口已经满足覆盖 t 的条件时（即 hashS 覆盖 hashT）
            // 尝试“收缩左边界”，让窗口尽可能变小，找到最小覆盖子串
            while (check(hashS, hashT)) // hashS 是否完全包含 hashT
            {
                // 当前窗口长度为 right - left + 1，更新最优答案
                int tmp = min(len, right - left + 1);
                if (tmp < len)
                {
                    len = tmp;      // 更新最小长度
                    index = left;   // 记录当前最优窗口的起始位置
                }

                // 收缩窗口：让左边界左移一个字符（即让最左边的字符出窗口）
                char out = s[left];
                hashS[out]--;   // 对应字符频次减一
                left++;         // 左指针右移，缩小窗口
            }
        }

        // 如果 len 仍然是初始值 INT_MAX，说明从未找到过满足条件的窗口
        // 返回空字符串 ""
        return INT_MAX == len ? "" : s.substr(index, len);
    }
};
```

### 4. 算法优化

原始版本里，是这么判断“当前窗口是否满足条件”的：

```cpp
bool check(const int hashS[], const int hashT[])
{
    for (int i = 0; i < 128; ++i)
        if (hashS[i] < hashT[i]) return false;
    return true;
}
```

也就是说：**每次** 右指针移动后，都要扫描 128 个字符，看窗口是否覆盖了 `t` 的需求。虽然 128 是常数，但逻辑上还是一种“全表对比”的方式。


#### 优化版本的核心改动

优化点：不再每次都遍历 128 个字符，而是用两个计数变量来 “懒判断” 是否满足条件。

##### 1️⃣ 预处理 t：得到 `hashT` 和 `kinds`

```cpp
int hashT[128] = { 0 };
int kinds = 0; // t 中需要匹配的不同字符种类数
for (const auto &ch : t) {
    if (hashT[ch] == 0) kinds++; // 首次出现的字符 → 种类 +1
    hashT[ch]++;
}
```

* `hashT[ch]`：`t` 中每个字符需要多少个；
* `kinds`：`t` 中一共有 **多少种不同的字符** 需要满足，比如：

  * `t = "ABC"` → kinds = 3
  * `t = "AABC"` → kinds 还是 3（A, B, C 三种）

##### 2️⃣ 窗口统计：`hashS` + `count`

```cpp
int hashS[128] = { 0 };
int count = 0; // 当前窗口中已经满足数量要求的字符种类数
```

滑动窗口右移时：

```cpp
char in = s[right];
hashS[in]++;

if (hashS[in] == hashT[in]) 
    count++; // 说明这个字符第一次“刚好满足”需求
```

含义：

* 当某个字符 `ch` 在窗口中的数量，从：
  * `< hashT[ch]` 变成 `== hashT[ch]` 时，表示：该字符的需求已经满足。
* 这时 `count++`，表示 “满足要求的字符种类”多了一种。

这样，**无需每次扫 128 个字符，只要看 `count` 是否和 `kinds` 相等**：

```cpp
while (count == kinds) {
    // 当前窗口已经覆盖 t 的全部字符，可以尝试缩小
}
```

##### 3️⃣ 收缩左边界时维护 `count`

当左指针右移，字符 `out` 离开窗口：

```cpp
char out = s[left];
if (hashS[out] == hashT[out]) 
    count--;        // 移除前，它是“刚好满足”的，移除后就不满足了
hashS[out]--;
left++;
```

逻辑是对称的：

* 在移除之前，`hashS[out] == hashT[out]`，说明这个字符原本是满足的；
* 移除一个之后，变成 `< hashT[out]`，这个字符的需求不再满足；
* 所以 `count--`，表示“满足要求的字符种类数”减少了一种。


##### 整体流程总结

1. 先扫一遍 `t`，数清楚：

   * 每个字符要多少个 (`hashT`)
   * 一共多少种字符要满足 (`kinds`)
2. 然后在 `s` 上开滑动窗口：

   * 右指针走一步，就把这个字符计数加一；
   * 某个字符的数量第一次达到需求时：`count++`
3. 当 `count == kinds` 时，说明当前窗口**已经包含了 t 所需的所有字符**：

   * 这时候不断右移左指针，尝试缩小窗口；
   * 每缩一次，就判断会不会破坏“满足条件”（通过维护 `count` 来判断）。
4. 整个过程不需要再对 128 个字符做全量比较，靠 `count` 和 `kinds` 两个变量就能动态知道“窗口是否满足条件”。


**如下图所示：**

![Alt text](./08%20image/image-2.png)

#### 算法代码
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        // 统计 t 中每个字符需要的数量
        int hashT[128] = { 0 };
        int kinds = 0; // t 中 “需要匹配的不同字符种类数”
        for (const auto &ch : t) 
        {
            if (hashT[ch] == 0) kinds++; // 首次出现的字符 → 种类 +1
            hashT[ch]++;
        }

        int hashS[128] = { 0 }; // 统计当前窗口中字符出现次数
        int index = -1;         // 最小覆盖子串的起始位置
        int len = INT_MAX;      // 最小覆盖子串长度
        int count = 0;          // 当前窗口中 “已经满足数量要求的字符种类数”

        int n = s.size();
        // 滑动窗口：右指针扩张窗口，左指针收缩窗口
        for (int left = 0, right = 0; right < n; ++right)
        {
            char in = s[right];
            hashS[in]++;  // 新字符进窗口

            // 某字符第一次达到 hashT 所需数量 → 窗口满足的种类数 +1
            if (hashS[in] == hashT[in])  count++;

            // 当 count == kinds 时，说明窗口已经完全覆盖 t，尝试收缩左边界
            while (count == kinds) 
            {
                int tmp = right - left + 1;
                if (tmp < len)           // 更新最小答案
                {
                    len = tmp;
                    index = left;
                }

                // 左边字符准备出窗口
                char out = s[left];

                // 如果移除后会导致该字符不再满足要求 → count -1
                if (hashS[out] == hashT[out]) count--;          
                
                hashS[out]--;            // 出窗口
                left++;                  // 缩小窗口
            }
        }

        return index == -1 ? "" : s.substr(index, len);
    }
};
```
