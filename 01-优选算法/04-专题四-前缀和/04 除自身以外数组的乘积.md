### 1. 题目链接

[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/)


**题目解析：**

![Alt text](./04%20image/image.png)


### 2. 解法（前缀和数组）

**算法思路:**

注意题目的要求，不能使用除法，并且要在 `O(N)` 的时间复杂度内完成该题。那么我们就不能使用暴力的解法，以及求出整个数组的乘积，然后除以单个元素的方法。

继续分析，根据题意，对于每一个位置的最终结果 `ret[i]`，它是由两部分组成的:
- `nums[0] * nums[1] * nums[2] * ... * nums[i - 1]`
- `nums[i + 1] * nums[i + 2] * ... * nums[n - 1]`

于是，我们可以利用前缀和的思想，使用两个数组 `post` 和 `suf`，分别处理出来两个信息:
- `post` 表示: `i` 位置之前的所有元素，即 `[0, i - 1]` 区间内所有元素的前缀乘积，
- `suf` 表示: `i` 位置之后的所有元素，即 `[i + 1, n - 1]` 区间内所有元素的后缀乘积

然后再处理最终结果。

**如下图所示：**

![Alt text](./04%20image/image-1.png)


### 3. 算法代码

**代码如下：**
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n), g(n);

        // 1. 预处理一下【前缀积】数组和【后缀积】数组
        f[0] = g[n - 1] = 1;
        for (int i = 1; i < n; i ++)
            f[i] = f[i - 1] * nums[i - 1];
        for (int i = n - 2; i >= 0; i --)
            g[i] = g[i + 1] * nums[i + 1];

        // 2. 使用
        vector<int> ret(n);
        for (int i = 0; i < n; i ++)
            ret[i] = f[i] * g[i];
            
        return ret;
            
    }
};
```