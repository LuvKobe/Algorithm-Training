### 1. 题目链接

[495. 提莫攻击](https://leetcode.cn/problems/teemo-attacking/description/)

**如图所示：**

![Alt text](./02%20image/image.png)


### 2. 解法 (模拟 + 分情况讨论)

**算法思路:**
- 模拟 + 分情况讨论。

**计算相邻两个时间点的差值:**
- 如果差值大于等于中毒时间，说明上次中毒可以持续 `duration` 秒；
- 如果差值小于中毒时间，那么上次的中毒只能持续两者的差值。

**如图所示：**

![Alt text](./02%20image/image-1.png)


### 3. 算法代码


```cpp
class Solution {
public:
    int findPoisonedDuration(vector<int>& timeSeries, int duration) {
        // 定义结果变量，记录总中毒秒数
        int ret = 0;
        // 从第2次攻击开始遍历，对比当前与上一次攻击的时间差（核心：处理中毒时间重叠）
        for (int i = 1; i < timeSeries.size(); i ++)
        {
            // 计算当前攻击与上一次攻击的时间间隔
            int x = timeSeries[i] - timeSeries[i - 1];
            // 情况1：时间间隔 >= 中毒持续时间，说明两次中毒无重叠，上一次贡献完整的duration秒
            if (x >= duration)
                ret += duration;
            else // 情况2：时间间隔 < 中毒持续时间，说明两次中毒有重叠，上一次仅贡献x秒有效中毒时间
                ret += x;
        }
        // 最后一次攻击的中毒时间一定是完整的duration秒，加上后返回总时间
        return ret + duration;
    }
};
```

**注释说明：**
- 从 `i = 1` 开始，因为需要通过 **相邻两次攻击的时间差** 判断中毒是否重叠，单独处理第一次攻击无意义；
- 核心是比较 **相邻攻击时间差x** 和 **中毒持续时间duration**：
   - 无重叠（`x≥duration`）：上一次攻击的中毒时间完全有效，加`duration`；
   - 有重叠（`x<duration`）：上一次攻击仅在 `[timeSeries[i-1], timeSeries[i]-1]` 有效，加`x`；
- 循环中未计算最后一次攻击的中毒时间，因其后续无攻击，中毒时间一定完整，直接加`duration`即可。
