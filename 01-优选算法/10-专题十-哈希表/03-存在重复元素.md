### 1. 题目链接

[217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/description/)


### 2. 解法（哈希表）

**算法思路：**

分析一下题目，出现「至少两次」的意思就是数组中存在着重复的元素，因此我们可以无需统计元素出现的数目。仅需在遍历数组的过程中，检查当前元素「是否在之前已经出现过」即可。

因此我们可以利用哈希表，仅需存储数「组内的元素」。在遍历数组的时候，一边检查哈希表中是否已经出现过当前元素，一边将元素加入到 哈希表中。


### 3. 算法代码

```cpp
class Solution 
{
public:
    // 函数功能：判断整数数组中是否存在重复元素
    // 参数：nums - 传入的整数数组（引用传递，避免拷贝开销）
    // 返回值：bool类型 - 存在重复返回true，否则返回false
    bool containsDuplicate(vector<int>& nums) 
    {
        // 定义一个无序集合（哈希集合），用于存储遍历过的数组元素
        // 无序集合的特点：查找、插入、删除操作的平均时间复杂度为O(1)，适合快速判重
        unordered_set<int> hash;
        
        // 遍历数组中的每一个元素（使用范围for循环，const auto& 避免不必要的拷贝且防止修改元素）
        // x 表示当前遍历到的数组元素
        for (const auto &x : nums)
        {
            // 检查当前元素 x 是否已经存在于哈希集合中
            // hash.count(x)：返回集合中 x 的出现次数（只能是0或1）
            if (hash.count(x)) 
                // 如果存在，说明找到重复元素，直接返回true
                return true;
            else 
                // 如果不存在，将当前元素插入到哈希集合中，供后续元素对比
                hash.insert(x);
        }
        
        // 遍历完整个数组后未发现重复元素，返回false
        return false;
    }
};
```

**总结：**
- 利用**无序哈希集合（unordered_set）** 的快速查找特性，遍历数组时实时检查元素是否已存在，存在则立即返回 true，否则将元素加入集合。
- 性能优势：哈希集合的 `count()` 和 `insert()` 操作平均时间复杂度为 O(1)，整体算法时间复杂度为 O(n)（n 为数组长度），空间复杂度为 O(n)（最坏情况存储所有元素）。
- 代码优化点：使用 `const auto &x` 遍历数组，避免拷贝数组元素，提升效率；找到重复元素时立即返回，无需遍历完整数组，减少不必要的计算。