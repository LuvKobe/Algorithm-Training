### 1. 题目链接

[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/)


### 2. 解法（滑动窗口）

**算法思路:**
题目要求的是数组「左端+右端」两段连续的、和为 `x` 的最短数组，信息量稍微多一些，不易理清思路；

我们可以转化成：求数组内一段连续的、和为 `sum(nums) - x` 的最长数组。此时，就是熟悉的「滑动窗口」问题了。

**如下图所示：**

![Alt text](./04%20image/image.png)


**算法流程:**

- 转化问题：求 `target = sum(nums) - x`。如果 `target < 0`，问题无解；

- 初始化左右指针 `left = 0`，`right = 0`（滑动窗口区间表示为 `[left, right)`，左右区间是否开闭很重要，必须设定与代码一致），记录当前滑动窗口内数组和的变量 `sum = 0`，记录当前满足条件数组的最大区间长度 `maxLen = -1`；

- 当 `right` 小于等于数组长度时，一直循环:
    - 如果 `sum < target`，右移右指针，直至变量和大于等于 `target`，或右指针已经移到头；
    - 如果 `sum > target`，右移左指针，直至变量和小于等于 `target`，或左指针已经移到头；
    - 如果经过前两步的左右移动使得 `sum == target`，维护满足条件数组的最大长度，并让下个元素进入窗口；

- 循环结束后，如果 `maxLen` 的值有意义，则计算结果返回；否则，返回 `-1`。


**如下图所示：**

![Alt text](./04%20image/image-1.png)


### 3. 算法代码

**代码实现：**
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        // 思路转化：
        // 原题：每次从左或右删一个数，并从 x 中减去这个数，最后希望 x 恰好变为 0。
        // 等价：从数组两端删除若干元素，它们的总和为 x。
        //      也就是保留下来的中间子数组的和 = 数组总和 sum - x。
        // 所以问题转化为：在 nums 中找一个“和为 target = sum - x 的最长连续子数组”，
        //      这样需要删除的元素个数 = 总长度 n - 这个子数组长度。
        
        int sum = 0;
        for (const auto &e : nums)
            sum += e;              // 计算整个数组的元素和
        
        int target = sum - x;      // 保留下来的子数组的目标和
        
        // 如果 target < 0，说明 x 大于整个数组的和，不可能通过删除得到和为 x
        if (target < 0) return -1;

        int len = -1;  // 记录“和为 target 的子数组”的最大长度，初始化为 -1 表示目前还没找到
        int ret = 0;   // 当前滑动窗口 [left, right] 内元素的和
        int n = nums.size();

        // 使用滑动窗口在 O(n) 时间内寻找：和为 target 的最长子数组
        // 左右指针都从 0 开始，右指针向右扩展，左指针按需收缩
        for (int left = 0, right = 0; right < n; right++)
        {
            ret += nums[right];    // 1. 右指针右移，将 nums[right] 加入当前窗口，窗口变大
            
            // 2. 当窗口内的和 ret > target 时，需要收缩左边界
            //    因为所有数都是非负整数，ret 只会越来越大，不可能通过继续扩展得到 target，
            //    只能通过左边不断弹出元素来减小 ret。
            while (ret > target)
            {
                // 3. 左指针右移，将 nums[left] 移出窗口
                ret -= nums[left];
                left++;
            }
            
            // 4. 如果当前窗口和恰好等于 target，更新最长子数组长度
            if (ret == target)
                len = max(len, right - left + 1);
        }

        // 如果 len 仍然为 -1，说明没有任何子数组和为 target，返回 -1
        if (len == -1)
            return len;
        else 
            // 否则，最少操作数 = 删除的元素个数 = 总长度 n - 保留下来的最长子数组长度 len
            return n - len;        // 注意：这里是最终答案的关键转换
    }
};
```