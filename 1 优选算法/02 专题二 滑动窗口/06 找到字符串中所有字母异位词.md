### 1. 题目链接

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)


### 2. 解法（滑动窗口+哈希表）

**算法思路:**
- 因为字符串 `p` 的异位词的长度一定与字符串 `p` 的长度相同，所以我们可以在字符串 `s` 中构造一个长度与字符串 `p` 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；

- 当窗口中每种字母的数量与字符串 `p` 中每种字母的数量相同时，则说明当前窗口为字符串 `p` 的异位词；

- 因此可以用两个大小为 `26` 的数组来模拟哈希表，一个来保存 `s` 中的子串每个字符出现的个数，另一个来保存 `p` 中每一个字符出现的个数。这样就能判断两个串是否是异位词。


**如图所示：**

![Alt text](./06%20image/image.png)


**算法代码：**
```cpp
class Solution {
public:
    // 比较两个 26 长度的数组是否完全相等
    bool check(int hash1[], int hash2[])
    {
        for (int i = 0; i < 26; i++)
        {
            if (hash1[i] != hash2[i])
                return false;
        }
        return true;
    }

    vector<int> findAnagrams(string s, string p) {
        vector<int> res; // 结果集：存放所有异位词起始下标
        int n = s.size(), m = p.size();
        if (n < m) return res;

        int hashP[26] = {0};  // p 的字符频次

        // 先统计 p 中每个字符的频次
        for (char c : p) hashP[c - 'a']++;

        int left = 0; // 滑动窗口左边界
        int hashS[26] = {0};  // 滑动窗口中统计 s 中字符出现次数

        // 遍历 s 的右指针（右边界）
        for (int right = 0; right < n; right++) 
        {
            hashS[s[right] - 'a']++;   // 当前字符进入窗口

            // 如果窗口大小超过 p 的长度，则将左端字符移出
            // 保持窗口长度始终 <= pLen
            if (right - left + 1 > m) {
                hashS[s[left] - 'a']--; // 移除窗口左端的字符
                left++; // 左端右移
            }

            // 若窗口大小刚好等于 p，则检查是否为异位词
            if (right - left + 1 == m) {
                if (check(hashP, hashS)) {
                    res.push_back(left); // 记录当前异位词开始下标
                }
            }
        }
        return res;
    }
};
```


### 3. 解法（滑动窗口 + 有效字符计数 count 优化版）

**算法思路:**

* 同样维护一个长度为 `p` 的滑动窗口，但不再每次比较整个 `26` 长度的频次数组，而是通过一个 `count` 变量记录窗口中 “有效匹配字符” 的数量；
* 当一个字符进入窗口时，如果它在窗口中的数量不超过 `p` 中该字符的需求，则说明这是一个有效匹配字符，令 `count++`；
* 当窗口超过长度 `m` 时，需要移除左侧字符，如果移除前该字符在窗口中的数量不超过 `p` 中的数量，说明移除的是有效匹配字符，需要令 `count--`；
* 当窗口长度恰好为 `m` 且 `count == m` 时，说明窗口内部恰好包含 `p` 所需要的全部字符（频次也完全一致），当前窗口即为一个异位词的起始位置。

**如下图所示：**

![Alt text](./06%20image/image-1.png)


**算法代码：**

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;               // 结果集：存放所有异位词的起始下标
        int n = s.size(), m = p.size();
        if (n < m) return res;         // s 比 p 还短，直接不可能存在异位词

        int hashP[26] = {0};           // 统计 p 中各字符出现次数（仅小写字母）
        for (char c : p) 
            hashP[c - 'a']++;          // 将 p 中字符计数

        int count = 0;                 // 记录窗口中“有效匹配字符”（未超过 hashP 需求）的数量
        int hashS[26] = {0};           // 当前滑动窗口中各字符的出现次数

        // 滑动窗口，right 为右边界，left 为左边界
        for (int left = 0, right = 0; right < n; right++) 
        {
            char in = s[right];                    // 即将进入窗口的字符
            hashS[in - 'a']++;                     // 该字符计数 +1

            // 若增加该字符后，窗口内该字符数 <= p 中需要的字符数
            // 说明这是一个“有效匹配字符”，计入 count
            if (hashS[in - 'a'] <= hashP[in - 'a'])
                count++; 

            // 如果窗口大小超过 p 的长度，需要缩小窗口
            if (right - left + 1 > m)
            {
                char out = s[left];                // 即将移出窗口的字符

                // 若移出前，该字符计数仍 <= p 中要求的数量
                // 说明移除的是一个有效匹配字符，因此需要 count--
                if (hashS[out - 'a'] <= hashP[out - 'a'])
                    count--;

                hashS[out - 'a']--;                // 移出字符，使窗口收缩
                left++;
            }

            // 若窗口大小刚好等于 m 且 count == m
            // 说明窗口内恰好有 m 个有效匹配字符，即是 p 的一个异位词
            if (m == count)
                res.push_back(left);
        }

        return res;
    }
};
```