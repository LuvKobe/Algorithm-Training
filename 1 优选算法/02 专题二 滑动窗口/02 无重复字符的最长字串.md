### 1. 题目链接

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

### 2. 解法一（暴力求解）

**算法思路：**

枚举「从每一个位置」开始往后，无重复字符的子串可以到达什么位置。找出其中长度最大的即可。

在往后寻找无重复子串能到达的位置时，可以利用「哈希表」统计出字符出现的频次，来判断什么时候子串出现了重复元素。

**算法代码：**
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = 0; /// 记录结果
        int n = s.lenght();

        // 1. 枚举从不同位置开始的最⻓重复⼦串
        // 枚举开始位置
        for (int i = 0; i < n; i ++)
        {
            // 创建一个哈希表, 统计频次
            int hash[128] = { 0 };

            // 寻找结束为止
            for (int j = i; j < n; j ++)
            {
                hash[ s[j] ]++; // 统计字符出现的频次

                if (hash[ s[j] ] > 1) // 如果出现重复的
                    break;

                // 如果没有重复，就更新len
                len = max(len, j - i + 1);
            }
        }
        // 2. 返回结果
        return len;
    }
};
```

### 3. 解法二（滑动窗口）

**算法思路：**

研究的对象依旧是一段连续的区间，因此继续使用「滑动窗口」思想来优化。

让滑动窗口满足：窗口内所有元素都是不重复的。

做法：右端元素 `ch` 进入窗口的时候，哈希表统计这个字符的频次：

- 如果这个字符出现的频次超过 `1`，说明窗口内有重复元素，那么就从左侧开始滑出窗口，直到 `ch` 这个元素的频次变为 `1`，然后再更新结果。
- 如果没有超过 `1`，说明当前窗口没有重复元素，可以直接更新结果。


**如下图所示：**

![Alt text](./02%20image/image.png)


**C++算法代码：**
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 1. 创建哈希表, 用来记录是否重复出现
        //   用【下标】来表示【字符】,
        //   用【数组内的元素】来记录是否重复出现
        //   如果 hash[48] = 0, 说明字符 '48' 没有出现
        //   如果 hash[48] = 1, 说明字符 '48' 出现 1 次
        int hash[128] = { 0 }; // 使用数组来模拟哈希表
        
        // 2. 做判断
        int n = s.size();
        int left = 0, right = 0;
        int len = 0;
        while (right < n)
        {
            hash[ s[right] ] ++; // 进窗口
            while (hash[ s[right] ] > 1) // 判断进入窗口的元素的个数是否大于1
            {
                // 出窗口
                hash[ s[left] ]--;
                left++;
            }
            len = max(len, right - left + 1); // 更新结果
            right++; // 让下一个元素进入窗口
        }
        return len;
    }
};
```



### 4. 数组索引的映射规则

`hash[128]` 是长度为 128 的数组，索引范围恰好是 `0~127`，与标准 ASCII 码值范围完全匹配。

因此映射关系为：
- 字符 `ch` → 其 ASCII 码值（`(int)ch`）→ 作为 `hash` 数组的索引 → 操作 `hash[(int) ch]`
- 由于 C 语言中 `char` 可以直接隐式转换为 `int`，所以简化为：`hash[ch]` 等价于 `hash[(int)ch]`

`hash` 数组初始值全为 `0`，通常用数组元素的值 表示对应字符的出现次数，步骤如下：
- 遍历字符串或字符序列；
- 对每个字符 ch，执行 `hash[ch]++`（利用映射关系，直接定位并累加计数）；
- 最终 `hash[ch]` 的值就是字符 `ch` 出现的次数。