### 1. 题目链接

[30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)

### 2. 解法（滑动窗口 + 哈希表 + count）

这道题其实和 [找到字符串中所有字母异位词](https://github.com/LuvKobe/Algorithm-Training/blob/main/1%20%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/02%20%E4%B8%93%E9%A2%98%E4%BA%8C%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/06%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md) 非常像，简直就是 Plus 版本，所以可以复用这个思路。

**算法思路：**

* 由于 `words` 中所有单词长度相同，设单词长度为 `len`，单词个数为 `m`，那么目标串联子串的总长度固定为 `m * len`。
* 在字符串 `s` 中，只有从索引 `0 ~ len - 1` 这些“按单词长度对齐”的起点出发，才能切出完整的单词块，因此我们对每一个起点 `i(0 ≤ i < len)` 分别执行一次滑动窗口：

  * 对固定的起点 `i`，我们让左右指针 `left`、`right` 都以步长 `len` 向右移动，每次把 `s` 中长度为 `len` 的子串视为一个“单词块”加入或移出窗口。
* 先用一个哈希表 `hashW` 统计 `words` 中每个单词出现的次数，表示“目标需求”；再用另一个哈希表 `hashS` 统计当前窗口中每个单词出现的次数，表示“窗口当前状态”。
* 维护一个整数 `count`，表示当前窗口中“匹配上 words 且未超过需求次数的单词数量”：

  * 当右指针 `right` 向右移动一个单词块 `in` 时，先令 `hashS[in]++`；

    * 若 `in` 在 `hashW` 中存在，且 `hashS[in] <= hashW[in]`，说明这个单词是一次有效匹配，令 `count++`。
  * 如果此时窗口总长度 `right - left + 1` 大于 `m * len`，说明窗口中单词数量超了，需要从左边移出一个单词块 `out`：

    * 在移出前，若 `out` 在 `hashW` 中存在，且 `hashS[out] <= hashW[out]`，说明移出的这个单词原本是有效匹配单词，需令 `count--`；
    * 然后执行 `hashS[out]--`，并将 `left` 向右移动一个单词长度 `len`。
* 当窗口长度恰好为 `m * len` 且 `count == m` 时，说明当前窗口中正好有 `m` 个有效匹配单词，并且每个单词的频次都没有超过 `words` 的需求，此时以 `left` 为起点的子串就是一个合法的“串联所有单词的子串”，将 `left` 加入结果集。
* 最后枚举完 `0 ~ len-1` 这几组起点对应的所有窗口后，返回收集到的所有起始下标即可。

**如下图所示：**

![Alt text](./07%20image/image.png)


**算法实现：**
```cpp
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ret;
        
        // 统计 words 中每个单词出现的频次（需求表）
        unordered_map<string, int> hashW;
        for (const auto &ch : words) hashW[ch]++;

        int len = words[0].size(); // words 里每个单词的长度（已知相同）
        int m = words.size();      // words 中单词个数
        
        // 一共需要执行 len 次滑动窗口，因为起点可能是 0 ~ len-1（按单词对齐）
        for (int i = 0; i < len; i++)
        {
            int n = s.size();
            int count = 0;                       // 当前窗口中“有效匹配单词”的数量
            unordered_map<string, int> hashS;    // 窗口中每个单词出现的频次

            // 左右指针均按单词长度 len 递进
            for (int left = i, right = i; right + len <= n; right += len)
            {
                // ----------- 进窗口 -----------
                string in = s.substr(right, len);   // 当前新加入窗口的单词
                hashS[in]++;                        // 记录窗口中该单词出现次数

                // 如果该单词是 words 中需要的，且出现次数没有超过需求，count++
                if (hashW.count(in) && hashS[in] <= hashW[in]) 
                    count++;
                
                // ----------- 判断窗口大小是否超过 m 个单词 -----------
                if (right - left + 1 > m * len)
                {
                    // ----------- 出窗口 -----------
                    string out = s.substr(left, len); // 将从窗口左侧移出的单词

                    // 如果该单词是 words 需要的，且移除前数量不超过需求，则 count--
                    if (hashW.count(out) && hashS[out] <= hashW[out]) 
                        count--;

                    hashS[out]--;   // 更新窗口频次
                    left += len;    // 左指针右移一个单词
                }

                // ----------- 判断窗口是否刚好匹配成功 -----------
                // 若 count == m，说明窗口中刚好有 m 个有效单词，即为一个完整匹配
                if (count == m)
                    ret.push_back(left);
            }
        }

        return ret;
    }
};
```
