### 1. 题目链接

[6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/description/)

**如图所示：**

![Alt text](image.png)


### 2. 解法一（模拟）

**如下图所示：**

![Alt text](image-1.png)


### 3. 解法二 (模拟 + 找规律)

算法思路:
找规律，用 `row` 代替行数，`row = 4` 时画出的 N 字形如下:
```
以从上往下、从左到右进行 Z 字形排列。
0　　　　　　           2row - 2　　　　　　          4row - 4
1　　      2row - 3    2row - 1　　　    4row - 5　　4row - 3
2　　2row-4　　　        2row　　4row - 6　　　       4row - 2
3　　　　　　           2row + 1　　　　　　           4row - 1
```

不难发现，数据是以 `2row - 2` 为一个周期进行规律变换的。将所有数替换成用周期来表示的变量:

第一行的数是：`0`, `2row - 2`, `4row - 4`；
第二行的数是：`1`, `(2row - 2) - 1`, `(2row - 2) + 1`, `(4row - 4) - 1`, `(4row - 4) + 1`；
第三行的数是：`2`, `(2row - 2) - 2`, `(2row - 2) + 2`, `(4row - 4) - 2`, `(4row - 4) + 2`；
第四行的数是：`3`, `(2row - 2) + 3`, `(4row - 4) + 3`。

可以观察到：
- 第一行、第四行为差为 `2row - 2` 的等差数列；
- 第二行、第三行除了第一个数取值为行数，每组下标为 `(2n - 1, 2n)` 的数围绕 `(2row - 2)` 的倍数左右取值。


**如下图所示：**

![Alt text](image-2.png)


### 4. 算法代码

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        // 处理边界情况：当行数为1时，字符串无需变换，直接返回原串
        if (numRows == 1) return s;

        // 计算Z字形的一个完整周期的字符数：竖列(numRows) + 斜列(numRows-2) = 2*numRows-2
        int d = 2 * numRows - 2;
        int size = s.size(); // 记录原字符串的长度，避免多次调用s.size()提升效率
        string ret; // 定义结果字符串，用于拼接Z字形变换后的字符

        // 1. 先处理Z字形的第一行
        // 第一行的字符索引规律：0, d, 2d, 3d... 即每次步长为一个完整周期d
        for (int i = 0; i < size; i += d)
            ret += s[i]; // 将符合规律的字符拼接到结果中

        // 2. 处理Z字形的中间行（第2行到第numRows-1行，对应索引k=1到k=numRows-2）
        for (int k = 1; k < numRows - 1; k ++)
        {
            // 中间行的每个周期有两个字符，索引分别为：k + n*d  和  (d - k) + n*d （n为周期数，从0开始）
            // 定义i为第一个字符的索引，j为第二个字符的索引，初始分别为k和d-k
            for (int i = k, j = d - k; i < size || j < size; i += d, j += d)
            {
                if (i < size) ret += s[i]; // 防止索引越界，符合条件则拼接第一个字符
                if (j < size) ret += s[j]; // 防止索引越界，符合条件则拼接第二个字符
            }
        }

        // 3. 处理Z字形的最后一行（第numRows行，对应索引numRows-1）
        // 最后一行的字符索引规律：numRows-1, numRows-1+d, numRows-1+2d... 步长同样为周期d
        for (int i = numRows - 1; i < size; i += d)
            ret += s[i]; // 将符合规律的字符拼接到结果中
        
        // 返回最终的Z字形变换结果
        return ret;
    }
};
```

**思路回顾：**
- 周期规律：Z字形排列的核心是存在固定周期 `2*numRows-2`，每个周期内的字符会按「竖列+斜列」的规律排列，这是代码中所有索引计算的基础；
- 分行处理：将Z字形分为「第一行、中间行、最后一行」三类处理，因为三类行的字符索引规律不同：
   - 第一/最后一行：每个周期仅 1 个字符，索引步长为周期 `d`；
   - 中间行：每个周期有 2 个字符，两个字符的索引分别与周期起点成 `k` 和 `d-k` 的偏移；
- 边界防护：
   - 提前处理 `numRows = 1` 的情况，避免周期 `d = 0` 导致的死循环；
   - 索引拼接前判断 `< size`，防止字符串越界访问。


