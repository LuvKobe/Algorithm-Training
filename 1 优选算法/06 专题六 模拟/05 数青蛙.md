### 1. 题目链接

[1419. 数青蛙](https://leetcode.cn/problems/minimum-number-of-frogs-croaking/)



**如下图所示：**

![Alt text](./05%20image/image.png)


### 2. 解法（模拟 + 分情况讨论）

**算法思路：**

模拟青蛙的叫声。

- 当遇到 `'r'` `'o'` `'a'` `'k'` 这四个字符的时候，我们要去看看每一个字符对应的前驱字符，有没有青蛙叫出来。如果有青蛙叫出来，那就让这个青蛙接下来喊出来这个字符；如果没有，直接返回 `-1`；
- 当遇到 `'c'` 这个字符的时候，我们去看看 `'k'` 这个字符有没有青蛙叫出来。如果有，就让这个青蛙继续去喊 `'c'` 这个字符；如果没有的话，就重新搞一个青蛙。

**如下图所示：**

![Alt text](./05%20image/image-1.png)


### 3. 算法代码


```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        // 标准蛙鸣的字符顺序，对应5个阶段：0(c)、1(r)、2(o)、3(a)、4(k)
        string t = "croak";
        int n = t.size(); // n=5，固定为蛙鸣的字符长度
        // hash数组：hash[i]表示当前处于第i个蛙鸣阶段的青蛙数量
        // 例如hash[0]是刚叫了c的青蛙数，hash[4]是刚叫了k的青蛙数（完成一次蛙鸣）
        vector<int> hash(n, 0);    

        // 建立字符到对应阶段下标的映射，快速查找每个字符属于哪个阶段
        unordered_map<char, int> index; 
        for (int i = 0; i < n; i++) {
            index[t[i]] = i;
        }
        
        // 遍历输入的蛙鸣混合字符串，逐个处理每个字符
        for (const auto &ch : croakOfFrogs)
        {
            // 情况1：当前字符是c（蛙鸣的起始）
            if (ch == 'c')
            {
                // 如果有青蛙完成了最后一个阶段k（hash[4]>0），说明这只青蛙可以复用
                if (hash[n - 1] != 0) {
                    hash[n - 1]--; // 复用的青蛙退出k阶段
                }
                hash[0]++; // 新增/复用的青蛙进入c阶段
            }
            // 情况2：当前字符是r/o/a/k（蛙鸣的中间/结束阶段）
            else
            {
                // 获取当前字符对应的阶段下标i
                int i = index[ch];
                // 检查前一个阶段i-1是否有青蛙：如果没有，说明字符顺序错误，无效蛙鸣
                if (hash[i - 1] == 0) {
                    return -1;
                }
                hash[i - 1]--; // 前一个阶段的青蛙减少1只（流转到当前阶段）
                hash[i]++;     // 当前阶段的青蛙增加1只
            }
        }
        
        // 遍历结束后，检查前4个阶段（c/r/o/a）是否还有青蛙
        // 如果有，说明有青蛙只叫了一半，未完成完整蛙鸣，返回-1
        for (int i = 0; i < n - 1; i ++) {
            if (hash[i] != 0) {
                return -1;
            }
        }

        // 最终hash[4]（k阶段）的数值就是最少需要的青蛙数：
        // 每只青蛙完成一次蛙鸣就会停在k阶段，可复用的青蛙也从k阶段流转回c阶段
        return hash[n - 1];
    }
};
```

**关键逻辑拆解：**
- 阶段定义：把`croak`拆分为5个连续阶段，用 `0~4` 下标对应，青蛙必须按 **0→1→2→3→4** 的顺序流转，无法跳过阶段；
- 青蛙复用：当遇到新的`c`时，如果有青蛙已完成k阶段（`hash[4]>0`），这只青蛙无需新增，直接从k阶段回到c阶段复用；
- 合法性校验：处理中间字符（r/o/a/k）时，若前一个阶段没有青蛙，说明字符顺序错误（比如先出现r再出现c），直接返回-1；
- 最终校验：遍历结束后，前4个阶段不能有剩余青蛙，否则存在未完成的蛙鸣（比如字符串以croa结尾），返回-1；
- 答案取值：`hash[4]`是最终完成蛙鸣的青蛙总数，也是 **最少需要的青蛙数**（因为能复用的都已复用，没有多余新增）。

**示例验证（以示例2为例）**

输入：`crcoakroak`（输出2）
- 处理`c`：hash[0]=1，其余0；
- 处理`r`：hash[0]→0，hash[1]=1；
- 处理`c`：无k阶段青蛙可复用，hash[0]=1（此时hash[1]=1、hash[0]=1，共2只青蛙，对应答案）；
- 后续字符按阶段流转，最终所有青蛙都完成k阶段，hash[4]=2，返回2，与示例一致。
