### 1. 题目链接

[1576. 替换所有的问号](https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/description/)


**如图所示：**

![Alt text](./01%20image/image.png)

### 2. 解法 (模拟)

**算法思路:**

- 纯模拟。从前往后遍历整个字符串，找到问号之后，就用 `a ~ z` 的每一个字符去尝试替换即可。

**如图所示：**

![Alt text](image-1.png)


### 3. 算法代码


```cpp
class Solution {
public:
    string modifyString(string s) {
        // 获取字符串的长度，方便后续遍历
        int n = s.size();
        // 遍历字符串的每一个字符
        for (int i = 0; i < n; i++) 
        {
            // 找到需要替换的问号字符
            if (s[i] == '?') // 替换当前的问号
            {
                // 从小写字母a到z依次尝试，找到符合条件的字符就替换
                for (char ch = 'a'; ch <= 'z'; ch++) 
                {
                    // 核心判断条件：当前尝试的字符ch，和左右相邻字符都不重复
                    // i == 0 表示是第一个字符，无左邻居；i == n - 1 表示是最后一个字符，无右邻居
                    if ((i == 0 || ch != s[i - 1]) && (i == n - 1 || ch != s[i + 1]))
                    {
                        // 找到符合条件的字符，替换当前问号
                        s[i] = ch;
                        // 找到后直接退出内层循环，无需尝试后续字母
                        break;
                    }
                }
            }
        }
        // 替换所有问号后，返回最终字符串
        return s;
    }
};
```

**注释说明：**
- 用 `i == 0` 和 `i == n - 1` 分别处理字符串 **第一个字符** 和 **最后一个字符** 的问号，避免访问数组越界；
- 从 `a` 到 `z` 按顺序尝试，找到第一个和左右都不重复的字符就替换，保证效率且满足题目“任意一个有效解即可”的要求；
- 内层循环找到符合条件的字符后用 `break` 退出，无需遍历所有26个字母，减少不必要的循环。
- 核心判断条件通过 **短路逻辑**（`||`）避免越界，同时保证替换后无连续重复字符；
