### 1. 题目链接

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)


**如下图所示：**

![Alt text](./01%20image/image.png)


### 2. 解法（哈希表）

**算法思路：**
- 如果我们可以事先将「数组内的元素」和「下标」绑定在一起存入「哈希表」中，然后直接在哈希表中查找每一个元素的 `target - nums[i]`，就能快速的找到「目标和的下标」。
- 这里有一个小技巧，我们可以不用将元素全部放入到哈希表之后，再来二次遍历（因为要处理元素相同的情况）。而是在将元素放入到哈希表中的「同时」，直接来检查表中是否已经存在当前元素所对应的目标元素（即 `target - nums[i]`）。如果它存在，那我们已经找到了对应解，并立即将其返回。无需将元素全部放入哈希表中，提高效率。
- 因为哈希表中查找元素的时间复杂度是 O(1)，遍历一遍数组的时间复杂度为 O(N)，因此可以将时间复杂度降到 O(N)。

**如下图所示：**

![Alt text](./01%20image/image-1.png)


### 3. 算法代码

```cpp
class Solution 
{
public:
    // 函数功能：在整数数组nums中找到和为target的两个数，返回它们的下标
    // 参数说明：nums - 输入的整数数组；target - 目标和值
    // 返回值：包含两个下标值的vector，如果未找到则返回{-1, -1}
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        // 定义一个无序哈希表，键值对为 <数组元素值, 元素对应的下标>
        // 用于快速查找目标元素是否存在，并获取其下标
        unordered_map<int, int> hash;

        // 遍历数组，逐个处理每个元素
        for (int i = 0; i < nums.size(); i ++)
        {
            // 计算当前元素需要匹配的目标值：target - 当前元素值
            int x = target - nums[i];
            // 检查哈希表中是否已经存在这个目标值
            // count(x)返回1表示存在，返回0表示不存在
            if (hash.count(x)) 
            {
                // 如果存在，直接返回目标值的下标和当前元素的下标
                return {hash[x], i};
            }
            // 如果不存在，将当前元素值和其下标存入哈希表
            // 注意：先检查再存入，避免使用同一个元素两次
            hash[nums[i]] = i;
        }
        // 题目假设必有解，此处为容错处理，返回{-1, -1}表示未找到
        return {-1, -1};
    }
};
```

**总结：**
- 使用哈希表存储已遍历元素的「值-下标」映射，将查找匹配元素的时间复杂度从O(n)降为O(1)，整体时间复杂度优化为O(n)。
- 遍历数组时先检查哈希表中是否存在当前元素的「互补值」（target - nums[i]），存在则直接返回结果，不存在则将当前元素存入哈希表。
- 先检查后存入哈希表，确保不会使用同一个元素两次来凑目标和。