### 1. 题目链接

[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/description/)


### 2. 解法 (位运算)

**算法思路:**
- 异或 `^` 运算本质是「无进位加法」；
- 按位与 `&` 操作能够得到「进位」；
- 然后一直循环进行，直到「进位」变成 `0` 为止。

**如下图所示：**

![Alt text](image.png)


### 3. 算法代码

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        // 循环直到没有进位（carry）为止
        // 核心思路：用位运算模拟加法，分为无进位和（异或）+ 进位（与运算后左移）
        while (b != 0)
        {
            // 1. 计算无进位和：a ^ b （异或运算，相同位为0，不同位为1，正好对应无进位加法）
            // 例如：1(01) ^ 2(10) = 3(11)，无进位；2(10) ^ 3(11) = 1(01)
            int x = a ^ b;
            
            // 2. 计算进位：(a & b) << 1
            // a & b 找出所有同时为1的位（这些位相加会产生进位）
            // << 1 左移1位，模拟进位到高位
            // 使用unsigned int避免负数左移导致的未定义行为
            unsigned int carry = (unsigned int)(a & b) << 1;
            
            // 3. 更新a为无进位和，b为进位，进入下一轮循环
            // 下一轮循环会把"无进位和"和"进位"继续相加，直到进位为0
            a = x;
            b = carry;
        }
        // 当进位b为0时，a就是最终的和
        return a;
    }
};
```

**总结:**
- 核心原理：加法可以拆解为 `无进位和（异或^） + 进位（与&后左移1位）`，循环直到进位为0。
- 关键细节：使用`unsigned int`转换进位值，避免负数左移操作引发的未定义行为。
- 终止条件：当进位`b`为0时，`a`即为两数之和，直接返回即可。