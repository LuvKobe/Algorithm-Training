### 1. 题目链接

[面试题 01.01. 判定字符是否唯一](https://leetcode.cn/problems/is-unique-lcci/description/)


### 2. 算法思路

**解法一：**

![Alt text](./02%20image/image.png)


**解法二：**

利用「位图」的思想，每一个「比特位」代表一个「字符」，一个 `int` 类型的变量的 `32` 位足够表示所有的小写字母。比特位里面如果是 `0`，表示这个字符没有出现过。比特位里面的值是 `1`，表示该字符出现过。

那么我们就可以用一个「整数」来充当「哈希表」。

**如下图所示：**


![Alt text](./02%20image/image-1.png)


### 3. 算法实现

**算法代码：**
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        // 利用鸽巢原理（抽屉原理）优化：
        // 小写字母只有26个，若字符串长度超过26，必然有重复字符，直接返回false
        if (astr.size() > 26) return false;

        // 定义一个整型变量作为位图（bitMap），用二进制位来记录字符是否出现过
        // 整型至少32位，足够覆盖26个小写字母（每一位对应一个字母：第0位对应'a'，第1位对应'b'...第25位对应'z'）
        int bitMap = 0;

        // 遍历字符串中的每一个字符（const auto保证只读，避免意外修改；ch是当前遍历到的字符）
        for (const auto ch : astr)
        {
            // 将小写字母转换为0-25的索引（'a'->0, 'b'->1...'z'->25）
            int i = ch - 'a';

            // 检查当前字符对应的位是否已经被标记（即字符是否已出现）：
            // 1. bitMap >> i：将bitMap右移i位，把第i位移到最低位
            // 2. & 1：与1做按位与，只保留最低位，判断该位是否为1（1表示已出现，0表示未出现）
            // 3. 若结果为1，说明字符重复，直接返回false
            if (1 == ((bitMap >> i) & 1)) return false;

            // 将当前字符对应的位标记为1（记录该字符已出现）：
            // 1. 1 << i：将1左移i位，得到仅第i位为1、其余位为0的数
            // 2. |：与bitMap做按位或，将第i位设为1，其余位保持不变
            bitMap = bitMap | (1 << i);
        }

        // 遍历完所有字符都未发现重复，返回true
        return true;
    }
};
```

**总结：**
- 核心优化点：利用 **鸽巢原理** 提前过滤长度>26的字符串，减少无效计算；
- 核心实现：用 **位图（bitMap）** 替代额外数据结构，通过整数的二进制位标记字符是否出现，空间复杂度仅O(1)；
- 关键操作：`ch - 'a'` 转换字母为索引，`>>`、`&` 判断位状态，`<<`、`|` 标记位状态，全程无额外数据结构。