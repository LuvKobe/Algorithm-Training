### 1. 题目链接

[面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/description/)


### 2. 解法 (位运算)

**算法思路:**
- 本题就是 [268.丢失的数字](https://leetcode.cn/problems/missing-number/description/) + [260.只出现一次的数字III](https://leetcode.cn/problems/single-number-iii/) 组合起来的题。

- 先将数组中的数和 `[1，n + 2]` 区间内的所有数「异或」在一起，问题就变成了：有两个数出现了「一次」，其余所有的数出现了「两次」。进而变成了 [260.只出现一次的数字III](https://leetcode.cn/problems/single-number-iii/) 这道题。

**如下图所示：**

![Alt text](image.png)


### 3. 算法代码

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> missingTwo(vector<int>& nums) {
        // 核心思路：利用异或的性质（x^x=0，x^0=x），先得到两个缺失数的异或结果a^b
        // 再通过异或结果的不同比特位，将所有数分成两组，每组分别异或得到a和b

        // 1. 将数组中所有数 与 1~N（N=nums.size()+2）所有数依次异或
        // 最终tmp的结果 = 缺失的第一个数a ^ 缺失的第二个数b（其余数都成对异或抵消为0）
        int tmp = 0;
        for (const auto &x : nums) tmp ^= x; // 先异或数组内所有元素
        for (int i = 1; i <= nums.size() + 2; i ++) // 再异或1到N的所有元素（N是完整数组的长度）
            tmp ^= i;

        // 2. 找到a和b的二进制中，**第一个不相同的比特位**（记为第diff位）
        // 因为a≠b，所以a^b的结果中至少有一位是1，该位即为a和b不同的位
        int diff = 0;
        while (1) // 从最低位（第0位）开始逐位检查
        {
            if (((tmp >> diff) & 1) == 1) break; // 找到第一个为1的比特位，退出循环
            else diff++; // 该位是0，继续检查下一位
        }

        // 3. 根据第diff位的二进制值（0或1），将所有数分成两组分别异或
        // 分组规则：第diff位为0的为一组，为1的为另一组
        // 性质：a和b会被分到不同组（因为第diff位是二者第一个不同位），其余数都会成对出现在同一组
        // 因此每组最终异或结果，就是对应的缺失数a和b
        int a = 0, b = 0;
        // 先对数组内的所有元素分组异或
        for (const auto &x : nums)
        {
            if (((x >> diff) & 1) == 1) // 第diff位为1，分到b组异或
                b ^= x;
            else // 第diff位为0，分到a组异或
                a ^= x;
        }
        // 再对1~N的所有元素分组异或（补全每组的成对元素，让非缺失数抵消）
        for (int i = 1; i <= nums.size() + 2; i ++)
        {
            if (((i >> diff) & 1) == 1) // 第diff位为1，分到b组异或
                b ^= i;
            else // 第diff位为0，分到a组异或
                a ^= i;
        }

        // 最终a和b即为缺失的两个数字，任意顺序返回即可
        return {a, b};
    }
};
```

**异或解法关键：**
- 异或的核心性质：`x ^ x = 0`（相同数异或抵消）、`x ^ 0 = x`（任何数和0异或不变），且异或满足交换律和结合律；
- 分组的依据：两个缺失数的异或结果中，**为 1 的比特位** 代表二者在该位不同，利用这一点可将二者分到不同组，保证每组最终能单独还原出一个缺失数；

示例验证（以输入[1]为例）
- 数组长度为1，完整N=1+2=3，需找1~3中缺失的2、3；
- 第一步异或：`tmp = 1 ^ (1^2^3) = 2^3 = 1`（二进制 `01`）；
- 第二步找diff：第 0 位是1，故 `diff=0`；
- 第三步分组：按第 0 位（奇偶位）分组，最终a组异或得2，b组异或得3，返回[2,3]，与示例结果一致。