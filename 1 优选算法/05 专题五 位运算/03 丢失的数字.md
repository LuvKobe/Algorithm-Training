### 1. 题目链接

[268. 丢失的数字](https://leetcode.cn/problems/missing-number/description/)


### 2. 算法思路

**解法一：**

![Alt text](./03%20image/image.png)


**解法二：**

![Alt text](./03%20image/image-1.png)


**解法三：位运算**

算法思路:
- 设数组的大小为 `n`，那么缺失之前的数就是 `[0, n]`，数组中是在 `[0, n]` 中缺失一个数形成的序列。
- 如果我们把数组中的所有数，以及 `[0, n]` 中的所有数全部 `异或` 在一起，那么根据 `异或` 运算的「消消乐」规律，最终的异或结果应该就是缺失的数~

**如下图所示：**

![Alt text](./03%20image/image-2.png)



### 3. 算法实现

**算法代码：**
```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        // 初始化结果变量为0，用于存储异或运算的最终结果
        int ret = 0;
        
        // 第一步：将数组中所有元素依次进行异或运算
        // 异或特性：相同数字异或结果为0，0与任何数字异或结果为该数字本身
        for (const auto &x : nums) ret ^= x;
        
        // 第二步：将[0, n]范围内的所有数字依次与ret进行异或运算（n = nums.size()）
        // 此时，除了丢失的数字外，其他数字都会被异或两次（数组中一次 + 此循环中一次），结果为0
        // 最终ret中只保留了丢失的数字（0异或丢失的数字 = 丢失的数字）
        for (int i = 0; i <= nums.size(); i ++) ret ^= i;
        
        // 返回丢失的数字
        return ret;
    }
};
```

这段代码利用了 **异或运算（^）** 的两个关键特性来高效解决问题：

以示例 1 `nums = [3,0,1]` 为例，执行过程如下：
- 第一步异或数组元素：`ret = 0 ^ 3 ^ 0 ^ 1 = 2`
- 第二步异或 [0,3] 范围：`ret = 2 ^ 0 ^ 1 ^ 2 ^ 3 = 2`（其中 0、1、2 都被异或两次抵消为 0，最终剩下 2）
