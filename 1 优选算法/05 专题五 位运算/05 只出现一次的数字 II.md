### 1. 题目链接

[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/description/)


### 2. 解法 (比特位计数)

**算法思路:**

- 设要找的数为 `ret`。
- 由于整个数组中，需要找的元素只出现了「一次」，其余的数都出现的「三次」，因此我们可以根据所有数的「某一个比特位」的总和 `%3` 的结果，快速定位到 `ret` 的「一个比特位上」的值是 `0` 还是 `1`。

- 这样，我们通过 `ret` 的每一个比特位上的值，就可以将 `ret` 给还原出来。

**如下图所示：**

![Alt text](image.png)


### 3. 算法代码


```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0; // 初始化结果为0，最终存储只出现一次的数字
        // 遍历整数的每一位（int型共32位，从第0位（最低位）到第31位（最高位））
        for (int i = 0; i < 32; i ++)   // 依次去修改ret中的每一位
        {
            int sum = 0; // 统计当前第i位上，所有数字的1的总个数
            // 遍历数组中所有数字，计算nums中所有的数的第 i 位的和
            for (const auto &x : nums)  
            {
                // 把x右移i位，再和1按位与，判断x的第i位是否为1；若是则统计数+1
                if ( ((x >> i) & 1) == 1 )
                    sum++;
            }
            sum %= 3; // 对3取余，其余数字出现3次，该位1的个数模3后仅两种结果：0（无目标数的1）、1（有目标数的1）
            if (1 == sum) // 若模3后为1，说明目标数字的第i位是1
                ret = ret | (1 << i); // 将ret的第i位设为1（1左移i位后和ret按位或）
        }
        return ret; // 返回最终找到的只出现一次的数字
    }
};
```


该解法的核心是 **按位统计+模3消去**，利用了「除目标数外，其余数都出现3次」的特性：
- 对整数的每一位单独统计，统计数组中所有数字该位上 `1` 的总个数；
- 由于其余数出现 3 次，其贡献的 `1` 的个数是 3 的倍数，模 3 后会被消去（结果为 0）；
- 最终模 3 的结果如果是 1，说明 **目标数的该位是 1**，否则是 0；
- 把所有为 1 的位组合起来，就是最终的目标数。

**关键点回顾：**
- 遍历 32 位是因为 C++ 中 `int` 为 32 位有符号整数，覆盖所有位即可还原目标数；
- `(x >> i) & 1`是 **获取数字 x 第 i 位值** 的经典写法，结果为 0 或 1；
- `ret | (1 << i)`是 **将数字 ret 第 i 位设为 1** 的经典写法，不改变其他位的值；