### 1. 题目链接

[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/)


**如下图所示：**

![Alt text](./03%20image/image.png)


### 2. 解法（归并排序）

**算法思路：**

这一道题的解法与 **[求数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)** 的解法是类似的，但是这一道题要求的不是求总的个数，而是要返回一个数组，记录每一个元素的右边有多少个元素比自己小。

但是在我们归并排序的过程中，元素的下标是会跟着变化的，因此我们需要一个辅助数组，来将数组元素和对应的下标绑定在一起归并，也就是再归并元素的时候，顺势将下标也转移到对应的位置上。

由于我们要快速统计出某一个元素后面有多少个比它小的，因此我们可以利用求逆序对的第二种方法。

**如下图所示：**

![Alt text](./03%20image/image-1.png)



**还需要创建辅助数组：**

![Alt text](./03%20image/image-2.png)

### 3. 算法流程

**创建两个全局的数组：**
- `vector<int> index`：记录下标
- `vector<int> ret`：记录结果
- `index` 用来与原数组中对应位置的元素绑定，`ret` 用来记录每个位置统计出来的逆序对的个数。

**`countSmaller()` 主函数：**
- 计算 `nums` 数组的大小为 `n`；
- 初始化定义的两个全局的数组；
  - 为两个数组开辟大小为 `n` 的空间
  - `index` 初始化为数组下标；
  - `ret` 初始化为 0
- 调用 `mergeSort()` 函数，并且返回 `ret` 结果数组。

**`void mergeSort(vector<int>& nums, int left, int right )` 函数：**
- 函数设计：通过修改全局的数组 `ret`，统计出每一个位置对应的逆序对的数量，并且排序；
- 无需返回值，因为直接对全局变量修改，当函数结束的时候，全局变量已经被修改成最后的结果。


### 4. `mergeSort()` 函数流程

定义递归出口：`left >= right` 时，直接返回；

划分区间：根据中点 `mid`，将区间划分为 `[left, mid]` 和 `[mid + 1, right]`；

**统计左右两个区间逆序对的数量：**
- 统计左边区间 `[left, mid]` 中每个元素对应的逆序对的数量到 `ret` 数组中，并排序；
- 统计右边区间 `[mid + 1, right]` 中每个元素对应的逆序对的数量到 `ret` 数组中，并排序。

**合并左右两个有序区间，并且统计出逆序对的数量：**
- 创建两个大小为 `right - left + 1` 大小的辅助数组：
    - `numsTmp`：排序用的辅助数组；
    - `indexTmp`：处理下标用的辅助数组。

- 初始化遍历数组的指针：`cur1 = left`（遍历左半边数组）`cur2 = mid + 1`（遍历右半边数组）`dest = 0`（遍历辅助数组）`curRet`（记录合并时产生的逆序对的数量）；

- 循环合并区间：
    - 当 `nums[cur1] <= nums[cur2]` 时：
        - 无需统计，直接归并，注意 `index` 也要跟着归并。
    - 当 `nums[cur1] > nums[cur2]` 时：
        - 说明此时 `[mid + 1, cur2)` 之间的元素都是小于 `nums[cur1]` 的，需要累加到 `ret` 数组的 `index[cur1]` 位置上（因为 `index` 存储的是元素对应位置在原数组中的下标）。
        - 另外，归并排序：不仅要将数据放在对应的位置上，也要将数据对应的坐标也放在对应的位置上，使数据与原始的下标绑定在一起移动。

- 处理归并排序中剩余的元素；
    - 当左边有剩余的时候，还需要统计逆序对的数量；
    - 当右边还有剩余的时候，无需统计，直接归并。

- 将辅助数组的内容替换到原数组中去；



### 5. 算法代码

```cpp
class Solution 
{
    vector<int> ret;
    vector<int> index; // 记录nums中当前元素的原始下标
    int tmpNums[500010];
    int tmpIndex[500010];
public:
    vector<int> countSmaller(vector<int>& nums) 
    {
        int n = nums.size();
        ret.resize(n);
        index.resize(n);

        // 初始化一下index数组
        for (int i = 0; i < n; i ++)
            index[i] = i;

        mergeSort(nums, 0, n - 1);
        return ret;
    }

    void mergeSort(vector<int>& nums, int left, int right)
    {
        // 边界情况
        if (left >= right) return;

        // 1. 根据中间元素划分区间
        // [left, mid] [mid + 1, right]
        int mid = (left + right) >> 1;

        // 2. 先处理左右两部分
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);

        // 3. 处理一左一右的情况
        int cur1 = left, cur2 = mid + 1, i = 0;
        while (cur1 <= mid && cur2 <= right)
        {
            if (nums[cur1] <= nums[cur2])
            {
                tmpNums[i] = nums[cur2];
                tmpIndex[i++] = index[cur2++];
            }
            else if (nums[cur1] > nums[cur2])
            {
                ret[index[cur1]] += right - cur2 + 1;
                tmpNums[i] = nums[cur1];
                tmpIndex[i++] = index[cur1++];
            }
        }

        // 4. 处理后续归并情况
        while (cur1 <= mid)
        {
            tmpNums[i] = nums[cur1];
            tmpIndex[i++] = index[cur1++];
        }
        while (cur2 <= right)
        {
            tmpNums[i] = nums[cur2];
            tmpIndex[i++] = index[cur2++];
        }
        for (int j = left; j <= right; j++)
        {
            nums[j] = tmpNums[j - left];
            index[j] = tmpIndex[j - left];
        }
    }
};
```