### 1. 题目链接

[【模板】二维前缀和](https://www.nowcoder.com/practice/99eb8040d116414ea3296467ce81cbbc)


**题目解析：**

![Alt text](./02%20image/image.png)


### 2. 解法


**算法思路：**

类比于一维数组的形式，如果我们能处理出来从 `[0, 0]` 位置到 `[i, j]` 位置这片区域内所有元素的累加和，就可以在 `O(1)` 的时间内，指定矩阵内任意区域内所有元素的累加和。因此我们接下来仅需完成两步即可。


#### 第一步: 搞出来前缀和矩阵

这里就要用到一维数组里面的拓展知识，我们要在矩阵的最上面和最左边添加上一行和一列 `0`，这样我们就可以省去非常多的边界条件的处理。处理后的矩阵就像这样:

![Alt text](./02%20image/image-1.png)


这样，我们填写前缀和矩阵数组的时候，下标直接从 `1` 开始，能大胆使用 `i - 1`, `j - 1` 位置的值。

注意 `dp` 表与原数组 `matrix` 内的元素的映射关系:
- 从 `dp` 表到 `matrix` 矩阵，横纵坐标减一；
- 从 `matrix` 矩阵到 `dp` 表，横纵坐标加一。

前缀和矩阵中 `sum[i][j]` 的含义，以及如何递推二维前缀和方程

a. `sum[i][j]` 的含义:

- `sum[i][j]` 表示，从 `[0, 0]` 位置到 `[i, j]` 位置这段区域内，所有元素的累加和。对应下图的红色区域:

![Alt text](./02%20image/image-2.png)

b. 递推方程:

- 其实这个递推方程非常像我们小学做过求图形面积的题，我们可以将 `[0, 0]` 位置到 `[i, j]` 位置这段区域分解成下面的部分:

![Alt text](./02%20image/image-3.png)


`sum[i][j]` = 红 + 蓝 + 绿 + 黄，分析一下这四块区域:
- 【黄色】部分最简单，它就是数组中的 `matrix[i - 1][j - 1]`（注意坐标的映射关系）
- 单独的【蓝】不好求，因为它不是我们定义的状态表示中的区域，同理，单独的【绿】也是；
- 但是如果是【红 + 蓝】，正好是我们 `dp` 数组中 `sum[i - 1][j]` 的值，美滋滋；
- 同理，如果是【红 + 绿】，正好是我们 `dp` 数组中 `sum[i][j - 1]` 的值；
- 如果把上面求的三个值加起来，那就是【黄 + 红 + 蓝 + 红 + 绿】，发现多算了一部分红的面积，因此再单独减去【红】的面积即可；
- 【红】的面积正好也是符合 `dp` 数组的定义的，即 `sum[i - 1][j - 1]`

综上所述，我们的递推方程就是:
- `sum[i][j]=sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]+matrix[i - 1][j - 1]`



#### 第二步: 使用前缀和矩阵

题目的接口中提供的参数是原始矩阵的下标，为了避免下标映射错误，这里直接先把下标映射成 `dp` 表里面对应的下标: `row1++`, `col1++`, `row2++`, `col2++`

接下来分析如何使用这个前缀和矩阵，如下图（注意这里的 `row` 和 `col` 都处理过了，对应的正是 `sum` 矩阵中的下标）:

![Alt text](./02%20image/image-4.png)


对于左上角 `(row1, col1)`、右下角 `(row2, col2)` 围成的区域，正好是红色的部分。因此我们要求的就是红色部分的面积，继续分析几个区域:

- 黄色，能直接求出来，就是 `sum[row1 - 1, col1 - 1]`（为什么减？因为要剔除掉 `row` 这一行和 `col` 这一列）
- 绿色，直接求不好求，但是和黄色拼起来，正好是 `sum` 表内 `sum[row1 - 1][col2]` 的数据；
- 同理，蓝色不好求，但是 【蓝 + 黄】 = `sum[row2][col1 - 1]`；
- 再看看整个面积，好求嘛？非常好求，正好是 `sum[row2][col2]`；
- 那么，【红色 = 整个面积 - 黄 - 绿 - 蓝】，但是绿蓝不好求，我们可以这样减：【整个面积-（绿+黄）-（蓝+黄）】，这样相当于多减去了一个黄，再加即可。

综上所述：【红 = 整个面积-（绿+黄）-（蓝+黄）+ 黄】，从而可得红色区域内的元素总和为:
`sum[row2][col2]-sum[row2][col1 - 1]-sum[row1 - 1][col2]+sum[row1 - 1][col1 - 1]`





### 3. 算法代码

根据上面的解析，我们可以得到：

![Alt text](./02%20image/image-5.png)


**代码实现：**
```cpp
#include <iostream>
#include <vector>
using namespace std;

using LL = long long; // 防止前缀和矩阵溢出
int main() 
{
    // 1.读取数据
    int  n = 0, m = 0, q = 0;
    cin >> n >> m >> q;
    // 定义一个 (n+1) 行、(m+1) 列 的二维 int 数组，所有元素都会被 初始化为 0
    vector<vector<int>> arr(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            cin >> arr[i][j];

    // 2.预处理前缀和矩阵
    vector<vector<LL>> dp(n + 1, vector<LL>(m + 1)); 
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + arr[i][j] - dp[i - 1][j - 1];

    // 3.使用前缀和矩阵
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    while (q --)
    {
        cin >> x1 >> y1 >> x2 >> y2;
        cout << dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1] << endl;
    }
}
```