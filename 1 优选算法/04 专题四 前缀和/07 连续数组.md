### 1. 题目链接

[525. 连续数组](https://leetcode.cn/problems/contiguous-array/description/)


### 2. 解法（前缀和在哈希表中）

（暴力解法就是枚举所有的子数组，然后判断子数组是否满足要求，这里不再赘述。）

**算法思路：**

稍微转化一下题目，就会变成我们熟悉的题：
- 本题让我们找出一段连续的区间，`0` 和 `1` 出现的次数相同。
- 如果将 `0` 记为 `-1`，`1` 记为 `1`，问题就变成了找出一段区间，这段区间的和等于 `0`。
- 于是，就和 [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/) 这道题的思路一样

**如下图所示：**

![Alt text](./07%20image/image.png)


设 `i` 为数组中的任意位置，用 `sum[i]` 表示 `[0, i]` 区间内所有元素的和。

想知道最大的「以 `i` 为结尾的和为 `0` 的子数组」，就要找到从左往右第一个 `x1` 使得 `[x1, i]` 区间内的所有元素的和为 `0`。那么 `[0, x1 - 1]` 区间内的和是不是就是 `sum[i]` 了。于是问题就变成：
- 找到在 `[0, i - 1]` 区间内，第一次出现 `sum[i]` 的位置即可。

我们不用真的初始化一个前缀和数组，因为我们只关心在 `i` 位置之前，第一个前缀和等于 `sum[i]` 的位置。因此，我们仅需用一个哈希表，一边求当前位置的前缀和，一边记录第一次出现该前缀和的位置。


**如下图所示：**

![Alt text](./07%20image/image-1.png)


### 3. 算法代码

**注意一下细节问题：**

![Alt text](./07%20image/image-2.png)

**代码实现：**
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        // 哈希表用于存储前缀和及其首次出现的位置
        unordered_map<int, int> hash;
        
        // 初始条件：前缀和为0时，虚拟位置是-1
        hash[0] = -1; // 方便处理从数组开头到当前位置的子数组

        int sum = 0, ret = 0; // sum为当前前缀和，ret记录最大长度

        // 遍历数组
        for (int i = 0; i < nums.size(); ++i) {
            // 计算当前位置的前缀和：
            // 若 nums[i] 为0，前缀和减1；若为1，前缀和加1
            sum = sum + (nums[i] == 0 ? -1 : 1); 

            // 如果前缀和sum曾经出现过
            if (hash.count(sum)) {
                // 计算当前子数组长度：当前位置减去前缀和相同的上一个位置
                ret = max(ret, i - hash[sum]);
            } else {
                // 如果前缀和sum第一次出现，记录下它出现的位置
                hash[sum] = i;
            }
        }

        // 返回最大长度
        return ret;
    }
};
```