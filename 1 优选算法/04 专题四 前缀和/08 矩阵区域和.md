### 1. 题目链接

[1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/description/)


**题目解析：**

![Alt text](image.png)


### 2. 解法

**算法思路:**

二维前缀和的简单应用题，关键就是我们在填写结果矩阵的时候，要找到原矩阵对应区域的「左上角」以及「右下角」的坐标。

**左上角：**
- 左上角坐标：`x1 = i - k`, `y1 = j - k`，但是由于会「超过矩阵」的范围，因此需要对 `0` 取一个 `max`。
- 因此修正后的坐标为：`x1 = max(0, i - k)`, `y1 = max(0, j - k)`;

**右上角：**
- 右下角坐标：`x1 = i + k`, `y1 = j + k`，但是由于会「超过矩阵」的范围，因此需要对 `m - 1`，以及 `n - 1` 取一个 `min`。
- 因此修正后的坐标为：`x2 = min(m - 1, i + k)`, `y2 = min(n - 1, j + k)`。


**如下图所示：**

![Alt text](image-1.png)

然后将求出来的坐标代入到「二维前缀和矩阵」的计算公式上即可~（但是要注意下标的映射关系）

**如下图所示：**

![Alt text](image-2.png)


**「二维前缀和矩阵」的计算公式：**

![Alt text](image-3.png)


### 3. 算法代码

**代码实现：**
```cpp
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        // m 表示矩阵行数，n 表示矩阵列数
        int m = mat.size(), n = mat[0].size();

        // ---------- 1. 构建二维前缀和矩阵 ----------
        // dp[i][j] 表示：原矩阵中 (0,0) 到 (i-1, j-1) 这个子矩阵的元素和
        // 多开一行一列（m+1, n+1），第 0 行和第 0 列全为 0，方便处理边界
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 前缀和递推公式：
                // 上方矩形 + 左方矩形 - 重叠部分 + 当前元素
                dp[i][j] = dp[i - 1][j]
                         + dp[i][j - 1]
                         - dp[i - 1][j - 1]
                         + mat[i - 1][j - 1];
            }
        }

        // ---------- 2. 利用前缀和计算每个位置的矩阵区域和 ----------
        vector<vector<int>> ret(m, vector<int>(n));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {

                // 计算以 (i, j) 为中心、半径为 k 的子矩阵边界
                // 注意：mat 是 0-based，下标范围需要裁剪到矩阵内
                // dp 是 1-based，所以最终要 +1
                int x1 = max(0, i - k) + 1;      // 子矩阵左上角行
                int y1 = max(0, j - k) + 1;      // 子矩阵左上角列

                int x2 = min(m - 1, i + k) + 1;  // 子矩阵右下角行
                int y2 = min(n - 1, j + k) + 1;  // 子矩阵右下角列

                // 使用二维前缀和公式计算子矩阵和
                // = 右下 - 上方 - 左方 + 左上重叠部分
                ret[i][j] = dp[x2][y2]
                          - dp[x1 - 1][y2]
                          - dp[x2][y1 - 1]
                          + dp[x1 - 1][y1 - 1];
            }
        }

        return ret;
    }
};
```