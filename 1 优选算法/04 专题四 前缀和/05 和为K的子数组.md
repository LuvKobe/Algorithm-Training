### 1. 题目链接

[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)


**题目解析：**

![Alt text](./05%20image/image.png)


## 2. 解法（将前缀和存在哈希表中）

**算法思路：**

![Alt text](./05%20image/image-1.png)

设 `i` 为数组中的任意位置，用 `sum[i]` 表示 `[0，i]` 区间内所有元素的和。

想知道有多少个「以 `i` 为结尾的和为 `k` 的子数组」，就要找到有多少个起始位置为 `x1，x2，x3…` 使得 `[x，i]` 区间内的所有元素的和为 `k`。那么 `[0，x]` 区间内的和是不是就是 `sum[i] - k` 了。于是问题就变成:
- 找到在 `[0，i - 1]` 区间内，有多少前缀和等于 `sum[i] - k` 的即可。

我们不用真的初始化一个前缀和数组，因为我们只关心在 `i` 位置之前，有多少个前缀和等于 `sum[i] - k`。因此，我们仅需用一个哈希表，一边求当前位置的前缀和，一边存下之前每一种前缀和出现的次数。

**如下图所示：**

![Alt text](./05%20image/image-2.png)


### 3. 算法代码

代码的思路如下：
- 使用一个哈希表 `hash` 来存储前缀和的出现次数。哈希表的键是前缀和，值是该前缀和出现的次数。
- 初始化时，`hash[0] = 1`，这是为了处理某个前缀和恰好等于 `k` 的情况。
- 维护一个变量 `sum` 来记录当前的前缀和。
- 对于每个元素，更新当前的前缀和 `sum`，然后检查 `sum - k` 是否在哈希表中。如果在，说明存在一个子数组的和为 `k`，将结果 `ret` 增加哈希表中 `sum - k` 出现的次数。
- 更新哈希表，增加当前前缀和 `sum` 的出现次数。

这种方法的时间复杂度是 `O(n)`，其中 `n` 是数组的长度，因为我们只需要遍历一次数组并进行常数时间的哈希表操作。

代码的具体实现如下：
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        hash[0] = 1;  // 初始情况下，前缀和为0的子数组有1个（即空子数组）

        int sum = 0, ret = 0;
        for(const auto &x : nums) {
            sum += x;
            if (hash.count(sum - k))  // 查找当前前缀和减去k的值是否出现过
                ret += hash[sum - k];  // 如果存在，那么就是和为k的子数组
            hash[sum]++;  // 更新当前前缀和出现的次数
        }
        return ret;
    }
};
```

### 示例

1. 输入：`nums = [1, 1, 1], k = 2`

   * 子数组 `[1, 1]` 和 `[1, 1]` 和为 2，因此输出 2。

2. 输入：`nums = [1, 2, 3], k = 3`

   * 子数组 `[1, 2]` 和 `[3]` 和为 3，因此输出 2。

该方法的优势是利用了哈希表，避免了暴力方法的重复计算，极大地提升了效率。

