### 1. 题目链接

[974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/)



### 2. 前置知识

本题需要的前置知识如下。

同余定理：
- 如果 `(a - b) % n == 0`，那么我们可以得到一个结论: `a % n == b % n`。用文字叙述就是，如果两个数相减的差能被 `n` 整除，那么这两个数对 `n` 取模的结果相同。
- 例如: `(26 - 2) % 12 == 0`，那么 `26 % 12 == 2 % 12 == 2`。

`c++` 中负数取模的结果，以及如何修正「负数取模」的结果：
- `c++` 中关于负数的取模运算，结果是「把负数当成正数，取模之后的结果加上一个负号」。
    - 例如: `-1 % 3 = -(1 % 3) = -1`
- 因为有负数，为了防止发生「出现负数」的结果，以 `(a % n + n) % n` 的形式输出保证为正。
    - 例如: `-1 % 3 = (-1 % 3 + 3) % 3 = 2`

**如下图所示：**
![Alt text](image.png)

### 3. 解法（前缀和在哈希表中）

思路与「560. 和为 K 的子数组」这道题的思路相似。

二者核心思路的关联在于：都基于 **前缀和+哈希表** 的方式优化时间复杂度，通过记录前缀信息的出现次数，快速匹配满足条件的子数组，将暴力解法的O(n²)复杂度优化为O(n)。

![Alt text](image-1.png)

设 `i` 为数组中的任意位置，用 `sum[i]` 表示 `[0, i]` 区间内所有元素的和。
- 想知道有多少个「以 `i` 为结尾的可被 `k` 整除的子数组」，就要找到有多少个起始位置为 `x1, x2, x3...` 使得 `[x, i]` 区间内的所有元素的和可被 `k` 整除。
- 设 `[0, x - 1]` 区间内所有元素之和等于 `a`，`[0, i]` 区间内所有元素的和等于 `b`，可得 `(b - a) % k == 0`。
- 由同余定理可得，`[0, x - 1]` 区间与 `[0, i]` 区间内的前缀和同余。于是问题就变成：
  - 找到在 `[0, i - 1]` 区间内，有多少前缀和的余数等于 `sum[i] % k` 即可。

我们不用真的初始化一个前缀和数组，因为我们只关心在 `i` 位置之前，有多少个前缀和等于 `sum[i] - k`。因此，我们仅需用一个哈希表，一边求当前位置的前缀和，一边存下之前每一种前缀和出现的次数。

**如下图所示：**
![Alt text](image-2.png)


### 4. 算法代码

**代码如下：**
```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        // 哈希表：key为前缀和模k的余数，value为该余数出现的次数
        // 核心作用：统计相同余数出现的次数，相同余数的两个前缀和之差对应的子数组和可被k整除
        unordered_map<int, int> hash;
        // 初始化：前缀和为0时（还未遍历任何元素），余数0出现1次
        // 处理边界情况：比如单个元素nums[i]本身能被k整除时，前缀和sum[i]%k=0，可直接匹配初始的1次
        hash[0 % k] = 1;

        int sum = 0;   // 记录遍历过程中的前缀和（从数组开头到当前元素的和）
        int ret = 0;   // 记录满足条件的子数组数量

        // 遍历数组中的每个元素
        for (const auto& x : nums)
        {
            sum += x; // 累加当前元素，更新前缀和
            
            // 计算前缀和模k的余数（处理负数余数的关键）
            // 步骤解析：
            // 1. sum % k 可能得到负数（比如sum=-2, k=5时，-2%5=-2）
            // 2. 加k后将负数余数转为正数（-2+5=3）
            // 3. 再模k确保余数在[0, k-1]范围内（避免k=0的情况，题目中k应为正整数）
            int r = (sum % k + k) % k; 
            
            // 如果该余数之前出现过，说明存在若干个前缀和与当前前缀和的差能被k整除
            // 每出现一次，就对应一个满足条件的子数组，因此累加出现次数
            if (hash.count(r))
                ret += hash[r];
            
            // 将当前余数的出现次数+1（供后续元素匹配）
            hash[r]++;
        }
        return ret; // 返回满足条件的子数组总数
    }
};
```

**核心逻辑验证（以示例1为例）**

示例1输入：`nums = [4,5,0,-2,-3,1], k = 5`，预期输出：7。

我们逐行模拟代码执行过程，清晰展示每一步的变量变化：

| 遍历元素 | sum（前缀和） | r = (sum%5 +5)%5 | hash初始状态 | hash.count(r) | ret变化 | hash更新后状态 |
|----------|---------------|------------------|--------------|---------------|---------|----------------|
| -        | 0             | 0                | {0:1}        | -             | 0       | {0:1}          |
| 4        | 4             | (4%5+5)%5=4      | {0:1}        | 否（无4）     | 0       | {0:1, 4:1}     |
| 5        | 9             | (9%5+5)%5=4      | {0:1,4:1}    | 是（4出现1次）| 0+1=1   | {0:1, 4:2}     |
| 0        | 9             | (9%5+5)%5=4      | {0:1,4:2}    | 是（4出现2次）| 1+2=3   | {0:1, 4:3}     |
| -2       | 7             | (7%5+5)%5=2      | {0:1,4:3}    | 否（无2）     | 3       | {0:1,4:3,2:1}  |
| -3       | 4             | (4%5+5)%5=4      | {0:1,4:3,2:1}| 是（4出现3次）| 3+3=6   | {0:1,4:4,2:1}  |
| 1        | 5             | (5%5+5)%5=0      | {0:1,4:4,2:1}| 是（0出现1次）| 6+1=7   | {0:2,4:4,2:1}  |

最终`ret=7`，与示例1的输出一致，验证了代码的正确性。
