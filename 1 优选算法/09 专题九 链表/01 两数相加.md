### 1. 题目链接

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)

**如下图所示：**

![Alt text](./01%20image/image-1.png)

### 2. 解法（模拟）

**算法思路：**

- 两个链表都是逆序存储数字的，即两个链表的个位数、十位数等都已经对应，可以直接相加。

- 在相加过程中，我们要注意是否产生进位，产生进位时需要将进位和链表数字一同相加。如果产生进位的位置在链表尾部，即答案位数比原链表位数长一位，还需要再 `new` 一个结点储存最高位。

**如下图所示：**

![Alt text](./01%20image/image.png)


### 3. 算法代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 节点存储的数字（0-9）
 *     ListNode *next;   // 指向下一个节点的指针
 *     ListNode() : val(0), next(nullptr) {}  // 默认构造函数，值为0，next为空
 *     ListNode(int x) : val(x), next(nullptr) {} // 构造函数，指定值，next为空
 *     ListNode(int x, ListNode *next) : val(x), next(next) {} // 构造函数，指定值和next指针
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
    {
        // 定义两个指针，分别指向两个输入链表的当前节点，用于遍历
        ListNode* cur1 = l1, *cur2 = l2;
        // 创建一个虚拟头结点（哨兵节点），值初始化为0，方便统一处理结果链表的头节点
        ListNode* newNode = new ListNode(0);    
        // 定义prev指针，作为新链表的尾指针，用于构建结果链表
        ListNode* prev = newNode; 
        int t = 0;  // 记录每次相加产生的进位（初始为0）
        
        // 循环条件：只要有一个链表没遍历完，或者还有进位需要处理，就继续循环
        while (cur1 || cur2 || t)
        {
            // 如果第一个链表当前节点不为空，将其值加到进位t中，并移动指针到下一个节点
            if (cur1)
            {
                t += cur1->val;
                cur1 = cur1->next;
            }
            // 如果第二个链表当前节点不为空，将其值加到进位t中，并移动指针到下一个节点
            if (cur2)
            {
                t += cur2->val;
                cur2 = cur2->next;
            }
            // 计算当前位的结果（t%10），创建新节点并挂载到prev的next位置
            prev->next = new ListNode(t % 10);
            // 尾指针后移，指向新创建的节点
            prev = prev->next;
            // 更新进位：t/10 得到十位及以上的数（即进位值）
            t /= 10;
        }
        // 虚拟头结点的next才是结果链表的真正头节点，赋值给prev
        prev = newNode->next;
        // 释放虚拟头结点的内存，避免内存泄漏
        delete newNode;
        
        // 返回结果链表的头节点
        return prev;
    }
};
```

**总结：**
- 利用虚拟头结点简化链表头处理，遍历两个链表时将对应位数值+进位相加，取余作为当前位结果，整除10作为新的进位。
- `cur1 || cur2 || t` 确保处理完所有链表节点，且最后一位的进位也能被处理（比如999+999=1998的最高位1）。
- 最后删除虚拟头结点，避免内存泄漏，保证代码健壮性。