### 1. 题目链接

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

**如下图所示：**

![Alt text](image.png)


### 2. 解法

**如下图所示：**

![Alt text](image-1.png)


### 3. 算法代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) 
    {
        // 当链表为空, 或者链表中只有一个结点的时候, 直接返回即可
        if (head == nullptr || head->next == nullptr) return head;

        // 创建虚拟头结点，简化链表头节点交换的边界处理
        ListNode *newHead = new ListNode(0);
        newHead->next = head;  // 将虚拟头结点指向原链表的头节点

        // 初始化四个指针：
        // prev: 待交换节点对的前驱节点（初始为虚拟头节点）
        // cur: 待交换的第一个节点
        // next: 待交换的第二个节点
        // nnext: 待交换节点对的后继节点（保存后续链表，防止断链）
        ListNode *prev = newHead, *cur = prev->next, *next = cur->next, *nnext = next->next;
        
        // 循环条件：当前待交换的两个节点都存在（避免空指针访问）
        while (cur && next)
        {
            // 核心交换逻辑：调整指针指向完成节点交换
            prev->next = next;    // 前驱节点指向第二个节点（交换后第一个节点）
            next->next = cur;     // 第二个节点指向第一个节点（交换后第二个节点）
            cur->next = nnext;    // 第一个节点指向后续链表（恢复链表连接）

            // 移动指针到下一组待交换的节点对
            prev = cur;           // 前驱节点更新为当前组的第一个节点（下一组的前驱）
            cur = nnext;          // 下一组第一个节点更新为当前组的后继节点
            if (cur) next = cur->next;  // 若下一组第一个节点存在，更新第二个节点
            if (next) nnext = next->next; // 若下一组第二个节点存在，更新后继节点
        }
        
        // 保存新的头节点（虚拟头节点的下一个节点）
        cur = newHead->next;
        // 释放虚拟头节点的内存，避免内存泄漏
        delete newHead;
        // 返回交换后的链表头节点
        return cur;
    }
};
```

**总结：**
- 通过 **虚拟头节点** 简化链表头交换的边界处理，使用四个指针分别记录前驱、待交换的两个节点、后继节点，避免交换过程中断链。
- 循环调整指针指向完成节点交换，每次交换后移动指针到下一组待交换节点，直到没有可交换的节点对。
- 使用完虚拟头节点后及时释放内存，避免内存泄漏，这是C++代码的重要最佳实践。