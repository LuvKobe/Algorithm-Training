### 1. 题目链接

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)


**如下图所示：**

![Alt text](./04%20image/image.png)


### 2. 解法一（暴力）

暴力解法大概率会超时，这里不过多赘述。

**如下图所示：**

![Alt text](./04%20image/image-1.png)



### 3. 解法二（利用堆）

**算法思路：**

- 合并两个有序链表是比较简单且做过的，就是用双指针依次比较链表 1、链表 2 未排序的最小元素，选择更小的那个加入有序的答案链表中。

- 合并 K 个升序链表时，我们依旧可以选择 K 个链表中，头结点值最小的那一个。那么如何快速的得到头结点最小的是哪一个呢？用堆这个数据结构就好啦~

- 我们可以把所有的头结点放进一个小根堆中，这样就能快速的找到每次 K 个链表中，最小的元素是哪个。


**如下图所示：**

![Alt text](./04%20image/image-2.png)


### 4. 解法二（代码实现）


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 链表节点存储的数值
 *     ListNode *next;   // 指向下一个节点的指针
 *     ListNode() : val(0), next(nullptr) {} // 默认构造函数
 *     ListNode(int x) : val(x), next(nullptr) {} // 带数值的构造函数
 *     ListNode(int x, ListNode *next) : val(x), next(next) {} // 带数值和下一个节点的构造函数
 * };
 */
class Solution 
{
public:
    // 函数功能：合并k个升序排列的链表，返回合并后的升序链表
    // 参数lists：存储k个升序链表头节点的数组
    ListNode* mergeKLists(vector<ListNode*>& lists) 
    {
        // 创建一个小根堆(默认是大根堆)
        // 定义lambda表达式作为比较规则：l1->val > l2->val 表示小根堆（堆顶是最小元素）
        // const ListNode* 避免修改节点值，l1/l2为待比较的两个链表节点指针
        auto cmp = [](const ListNode* l1, const ListNode* l2){ return l1->val > l2->val; }; 
        
        // 初始化优先队列（小根堆）：
        // 模板参数说明：
        // 1. ListNode*：堆中存储的元素类型（链表节点指针）
        // 2. vector<ListNode*>：堆的底层存储容器类型
        // 3. decltype(cmp)：获取lambda表达式cmp的类型，作为比较规则类型
        // 构造函数传入cmp：将lambda实例作为比较规则传入堆
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> heap(cmp);

        // 遍历所有链表，将非空链表的头节点加入小根堆
        for(const auto &l : lists)
        {
            if (l) // 过滤空链表，避免空指针访问
            {
                heap.push(l); // 非空头节点入堆，堆会自动按val升序排列
            }
        }

        // 合并k个有序链表的核心逻辑
        ListNode* ret = new ListNode(0); // 创建哑节点（哨兵节点），简化链表操作
        ListNode* prev = ret; // 定义尾指针，始终指向合并后链表的最后一个节点
        // 循环取出堆顶元素（当前最小节点），直到堆为空
        while (!heap.empty())
        {
            ListNode* t = heap.top(); // 取出堆顶元素（当前所有链表中最小的节点）
            heap.pop(); // 弹出堆顶元素，避免重复使用
            prev->next = t; // 将当前最小节点接入合并后的链表
            prev = t; // 尾指针后移，指向新的最后一个节点
            // 如果当前节点的下一个节点不为空，将其加入堆中继续参与比较
            if (t->next) heap.push(t->next);
        }

        // 释放哑节点并返回合并后的有效链表头节点
        prev = ret->next; // 保存合并后链表的真实头节点（跳过哑节点）
        delete ret; // 释放哑节点内存，避免内存泄漏
        return prev; // 返回合并后的升序链表头节点
    }
};
```

**总结：**
- 标注了**优先队列模板参数含义**、**lambda比较规则逻辑**、**哑节点的作用**，以及每一步链表操作的目的；
- 明确了`heap.pop()`的作用（避免死循环）、`if (l)`的意义（过滤空链表）、`delete ret`的目的（防止内存泄漏）；


### 5. 解法三（递归 - 分治）


**算法思路：**

逐一比较时，答案链表越来越长，每个跟它合并的小链表的元素都需要比较很多次才可以成功排序。

比如，我们有 8 个链表，每个链表长为 100。

逐一合并时，我们合并链表的长度分别为 (0, 100), (100, 100), (200, 100), (300, 100), (400, 100), (500, 100), (600, 100), (700, 100)。所有链表的总长度共计 3600。

如果尽可能让长度相同的链表进行 **两两合并** 呢？这时合并链表的长度分别是 (100, 100) × 4, (200, 200) × 2, (400, 400)，共计 2400。比上一种的计算量整整少了 1/3。

迭代的做法代码细节会稍多一些，这里给出递归的实现，代码相对简洁，不易写错。


**算法流程：**
- 特判，如果题目给出空链表，无需合并，直接返回；
- 返回递归结果。

**递归函数设计：**
- 递归出口：如果当前要合并的链表编号范围左右值相等，无需合并，直接返回当前链表；
- 应用二分思想，等额划分左右两段需要合并的链表，使这两段合并后的长度尽可能相等；
- 对左右两段分别递归，合并 [l, r] 范围内的链表；
- 再调用 `mergeTwoLists` 函数进行合并（就是合并两个有序链表）。

**如下图所示：**

![Alt text](./04%20image/image-3.png)


### 6. 解法三（代码实现）


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;          // 节点存储的数值
 *     ListNode *next;   // 指向下一个节点的指针
 *     ListNode() : val(0), next(nullptr) {}  // 默认构造函数
 *     ListNode(int x) : val(x), next(nullptr) {} // 带数值的构造函数
 *     ListNode(int x, ListNode *next) : val(x), next(next) {} // 带数值和后继节点的构造函数
 * };
 */
class Solution 
{
public:
    // 主函数：合并K个升序链表的入口
    ListNode* mergeKLists(vector<ListNode*>& lists) 
    {
        // 调用分治合并函数，初始合并范围是整个链表数组[0, lists.size()-1]
        return merge(lists, 0, lists.size() - 1);
    }

    // 分治核心函数：递归合并数组中[left, right]区间内的所有链表
    // lists: 待合并的链表数组
    // left: 当前合并区间的左边界
    // right: 当前合并区间的右边界
    ListNode* merge(vector<ListNode*>& lists, int left, int right)
    {
        // 处理边界情况：左边界超过右边界，说明没有链表需要合并，返回空
        if (left > right) return nullptr;
        // 边界情况：区间内只有一个链表，直接返回该链表（递归终止条件）
        if (left == right) return lists[left];

        // 1. 平分数组：将当前区间拆分为左右两个子区间
        // (left + right) >> 1 等价于 (left + right) / 2，位运算效率更高
        int mid = (left + right) >> 1;

        // 2. 递归处理左右子区间：分别合并左半区和右半区的链表
        ListNode* l1 = merge(lists, left, mid);       // 合并左半区间[left, mid]的链表
        ListNode* l2 = merge(lists, mid + 1, right);  // 合并右半区间[mid+1, right]的链表

        // 3. 合并两个有序链表：将左右子区间合并后的两个有序链表再合并为一个
        return mergeTwoList(l1, l2);
    }

    // 辅助函数：合并两个已经升序排列的链表，返回合并后的升序链表头节点
    ListNode* mergeTwoList(ListNode* l1, ListNode* l2)
    {
        // 处理边界情况：如果其中一个链表为空，直接返回另一个链表
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;

        // 合并两个有序链表：创建虚拟头节点（简化链表操作，避免处理头节点为空的特殊情况）
        ListNode* head = new ListNode(0);  // 虚拟头节点，值无意义
        ListNode* prev = head;             // 遍历指针，始终指向合并后链表的最后一个节点
        ListNode* cur1 = l1, *cur2 = l2;   // 分别指向两个待合并链表的当前节点

        // 循环比较两个链表的当前节点，选择较小的节点接入合并链表
        while (cur1 && cur2)  // 只要两个链表都还有节点未处理
        {
            // 如果l1当前节点值更小（或相等），将其接入合并链表
            if (cur1->val <= cur2->val)
            {
                prev->next = cur1;    // 接入当前节点
                prev = prev->next;    // 移动合并链表的尾指针
                cur1 = cur1->next;    // 移动l1的指针到下一个节点
            }
            else // cur2->val < cur1->val：l2当前节点值更小，接入合并链表
            {
                prev->next = cur2;    // 接入当前节点
                prev = prev->next;    // 移动合并链表的尾指针
                cur2 = cur2->next;    // 移动l2的指针到下一个节点
            }
        }

        // 处理剩下的情况：其中一个链表已遍历完，直接拼接另一个链表的剩余节点
        if (cur1) prev->next = cur1;  // l1还有剩余节点，直接拼接
        if (cur2) prev->next = cur2;  // l2还有剩余节点，直接拼接

        // 返回结果：跳过虚拟头节点，释放虚拟头节点内存
        prev = head->next;  // 保存合并后链表的真实头节点
        delete head;        // 释放虚拟头节点，避免内存泄漏
        return prev;        // 返回合并后的有序链表头节点
    }
};
```

**总结：**
- 采用 **分治思想**，将合并K个链表的问题拆解为多次 “合并两个有序链表” 的子问题，先递归拆分链表数组，再自底向上合并。
- 关键步骤：
   - 分：通过递归将链表数组拆分为左右两个子区间，直到区间内只剩一个链表；
   - 治：调用`mergeTwoList`函数合并两个有序链表，该函数通过虚拟头节点简化链表操作，逐节点比较后拼接；
- 使用位运算`(left + right) >> 1`代替除法，减少计算开销；合并完成后释放虚拟头节点，避免内存泄漏。