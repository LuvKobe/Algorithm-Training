### 1. 题目链接

[75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/)

**如下图所示：**

![Alt text](image-1.png)

### 2. 解法（快排思想 - 三指针法使数组分三块）

**算法思路：**

类比数组分两块的算法思想，这里是将数组分成三块，那么我们可以再添加一个指针，实现数组分三块。

设数组大小为 `n`，定义三个指针 `left`，`cur`，`right`：
- `left`：用来标记 0 序列的末尾，因此初始化为 `-1`；
- `cur`：用来扫描数组，初始化为 `0`；
- `right`：用来标记 2 序列的起始位置，因此初始化为 `n`。

在 `cur` 往后扫描的过程中，保证：
- `[0，left]` 内的元素都是 0；
- `[left + 1，cur - 1]` 内的元素都是 1；
- `[cur，right - 1]` 内的元素是待定元素；
- `[right，n]` 内的元素都是 2。


### 3. 算法流程

- 初始化 `cur = 0`，`left = -1`，`right = numsSize`；

- 当 `cur < right` 的时候（因为 `right` 表示的是 2 序列的左边界，因此当 `cur` 碰到 `right` 的时候，说明已经将所有数据扫描完毕了），一直进行下面循环：
- 根据 `nums[cur]` 的值，可以分为下面三种情况：
    - `nums[cur] == 0`：说明此时这个位置的元素需要在 `left + 1` 的位置上，因此交换 `left + 1` 与 `cur` 位置的元素，并且让 `left++`（指向 0 序列的右边界），`cur++`（为什么可以 ++ 呢，是因为 `left + 1` 位置要么是 0，要么是 `cur`，交换完毕之后，这个位置的值已经符合我们的要求，因此 `cur++`）；
    - `nums[cur] == 1`：说明这个位置应该在 `left` 和 `cur` 之间，此时无需交换，直接让 `cur++`，判断下一个元素即可；
    - `nums[cur] == 2`：说明这个位置的元素应该在 `right - 1` 的位置，因此交换 `right - 1` 与 `cur` 位置的元素，并且让 `right--`（指向 2 序列的左边界），`cur` 不变（因为交换过来的数是没有被判断过的，因此需要在下轮循环中判断）
- 当循环结束之后：
- `[0，left]` 表示 0 序列；
- `[left + 1，right - 1]` 表示 1 序列；
- `[right，numsSize - 1]` 表示 2 序列。


**如下图所示：**

![Alt text](image.png)


### 4. 算法代码

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) 
    {
        int n = nums.size(); // 获取数组长度
        
        // left:0区右边界(初始-1表示无0), right:2区左边界(初始n表示无2), i:遍历指针，循环条件i<right(2区左侧才待处理)
        for (int left = -1, right = n, i = 0; i < right; )
        {
            if (nums[i] == 0) swap(nums[++left], nums[i++]); // 0划入0区，left右移，交换后i右移
            else if (nums[i] == 2) swap(nums[--right], nums[i]); // 2划入2区，right左移，交换后i不变(新元素需重新判断)
            else if (nums[i] == 1) i++; // 1在中间区，直接遍历下一个
        }
    }
};
```