### 1. 题目链接

[912. 排序数组](https://leetcode.cn/problems/sort-an-array/description/)


### 2. 解法（数组分三块思想 + 随机选择基准元素的快速排序）

**算法思路：**
我们在数据结构阶段学习的快速排序的思想可以知道，快排最核心的一步就是 **Partition（分割数据）**：将数据按照一个标准，分成左右两部分。

如果我们使用荷兰国旗问题的思想，将数组划分为 **左、中、右** 三部分：
- 左边是比基准元素小的数据；
- 中间是与基准元素相同的数据；
- 右边是比基准元素大的数据；
- 然后再去递归的排序左边部分和右边部分即可（可以舍去大量的中间部分）。

在处理数据量有很多重复的情况下，效率会大大提升。

**如下图所示：**

![Alt text](image.png)


### 3. 算法流程

**随机选择基准算法流程：**

函数设计：`int randomKey(vector<int>& nums, int left, int right)`
- 在主函数那里种一颗随机数种子；
- 在随机选择基准函数这里生成一个随机数；
- 由于我们要随机产生一个基准，因此可以将随机数转换成随机下标：让随机数 % 上区间大小，然后加上区间的左边界即可。

**如下图所示：**

![Alt text](image-1.png)


**快速排序算法主要流程：**
- 定义递归出口；
- 利用随机选择基准函数生成一个基准元素；
- 利用荷兰国旗思想将数组划分成三个区域；
- 递归处理左边区域和右边区域。


### 4. 算法代码

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) 
    {
        srand(time(NULL)); // 种下一颗随机数种子
        qsort(nums, 0, nums.size() - 1);
        return nums;
    }

    // 快排
    void qsort(vector<int>& nums, int l, int r)
    {
        if (l >= r) return; // 递归出口

        // 数组分三块
        int key = getRandom(nums, l, r);

        // 初始化的时候：left指向下标-1, right指向下标n, i指向下标0
        int i = l, left = l - 1, right = r + 1;

        while (i < right)
        {
            if (nums[i] < key) swap(nums[++left], nums[i++]);
            else if (nums[i] == key) i++;
            else if (nums[i] > key) swap(nums[--right], nums[i]);
        }

        // 此时数组已经分成了三块：
        // [l, left] [left + 1, right - 1] [right, r]
        qsort(nums, l, left);
        qsort(nums, right, r);
    }

    // 从数组中获取一个随机数
    int getRandom(vector<int>& nums, int left, int right)
    {
        int r = rand();
        return nums[r % (right - left + 1) + left];
    }
};
```