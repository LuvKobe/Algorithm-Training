### 1. 题目链接

[剑指offer 40.最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/)


**如下图所示：**

![Alt text](./04%20image/image.png)


### 2. 解法（快速选择算法）

**算法思路：**

- 在快速排序中，当我们把数组分成三块：`[l, left]`、`[left + 1, right - 1]`、`[right, r]`之后，我们可以通过计算每一个区间内元素的个数，进而推断出**最小的 k 个数**在哪些区间里面。

- 那么我们可以直接去「相应的区间」继续划分数组即可。


**如下图所示：**

![Alt text](image-1.png)


### 3. 算法代码

```cpp
class Solution {
public:
    // 主函数：返回库存中余量最少的cnt个商品（顺序不限）
    vector<int> inventoryManagement(vector<int>& stock, int cnt) 
    {
        // 处理边界情况：cnt为0时直接返回空数组
        if (cnt == 0) return {};
        // 种下一颗随机数种子，保证每次运行的随机基准元素不同，避免最坏时间复杂度
        srand(time(nullptr));
        // 调用快速选择函数，将最小的cnt个元素放到数组前cnt位
        qsort(stock, 0, stock.size() - 1, cnt);
        // 截取数组前cnt个元素返回（顺序不限）
        return {stock.begin(), stock.begin() + cnt};
    }

    // 快速选择核心函数：在nums[l..r]范围内找到最小的k个元素，放到数组前k位
    // l: 当前处理区间左边界，r: 当前处理区间右边界，k: 需要找的最小元素个数
    void qsort(vector<int>& nums, int l, int r, int k)
    {
        // 递归终止条件：区间只有一个元素或无元素，无需处理
        if (l >= r) return;

        // 1. 随机选择基准元素（避免有序数组导致的性能退化）
        int key = getRandom(nums, l, r);

        // 2. 三路划分：将数组分为 <key、==key、>key 三个部分
        // left: <key区域的右边界（初始为l-1，表示无元素）
        // right: >key区域的左边界（初始为r+1，表示无元素）
        // i: 当前遍历的指针，从左边界l开始
        int left = l - 1, right = r + 1, i = l;
        while (i < right) // 遍历到>key区域左边界为止
        {
            if (nums[i] < key) 
            {
                // 当前元素小于基准，放入<key区域，left右移，i右移
                swap(nums[++left], nums[i++]);
            }
            else if (nums[i] == key) 
            {
                // 当前元素等于基准，直接跳过，i右移
                i++;
            }
            else if (nums[i] > key) 
            {
                // 当前元素大于基准，放入>key区域，right左移（i不右移，因为交换过来的元素还未判断）
                swap(nums[--right], nums[i]);
            }
        }

        // 3. 此时数组分为三块：[l, left] <key、[left+1, right-1] ==key、[right, r] >key
        int a = left - l + 1; // 左区间（<key）的元素个数
        int b = right - left - 1; // 中间区间（==key）的元素个数
        
        // 分情况递归处理，只处理需要的区间，减少不必要的计算
        if (a > k) 
        {
            // 情况1：左区间元素个数超过k，说明最小的k个元素都在左区间，递归处理左区间
            qsort(nums, l, left, k);
        }
        else if (a + b >= k) 
        {
            // 情况2：左区间+中间区间元素个数>=k，说明最小的k个元素已经找到（左+部分中间），直接返回
            return;
        }
        else 
        {
            // 情况3：左+中间区间元素个数<k，说明还需要在右区间找 (k-a-b) 个最小元素
            qsort(nums, right, r, k - a - b);
        }
    }

    // 辅助函数：在nums[left..right]范围内随机选择一个元素作为基准值
    int getRandom(vector<int>& nums, int left, int right)
    {
        // 生成0到RAND_MAX之间的随机数
        int r = rand();
        // 将随机数映射到[left, right]区间，得到随机下标
        int keyId = r % (right - left + 1) + left;
        // 返回该随机下标对应的元素作为基准
        return nums[keyId];
    }
};
```
