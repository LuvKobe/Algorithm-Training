### 1. 题目链接

[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)


**如下图所示：**

![Alt text](./03%20image/image.png)


### 2. 解法（快速选择算法）

**算法思路：**

- 在快速排序中，当我们把数组分成三块：`[l, left]`、`[left + 1, right - 1]`、`[right, r]`之后，我们可以通过计算每一个区间内元素的个数，进而推断出我们要找的元素是在「哪一个区间」里面。

- 那么我们可以直接去 **相应的区间** 去寻找最终结果就好了。

**如下图所示：**

![Alt text](image-1.png)


### 3. 算法代码

```cpp
class Solution {
public:
    // 主函数：找到数组中第k个最大的元素
    int findKthLargest(vector<int>& nums, int k) 
    {
        // 初始化随机数种子，确保每次随机选择基准元素的结果不同
        srand(time(nullptr));

        // 调用快速选择核心函数，参数：数组、左边界、右边界、目标k
        return qsort(nums, 0, nums.size() - 1, k);
    }

    // 快速选择核心函数：在nums[l...r]范围内找到第k大的元素
    // 思路：基于快速排序的分治思想，无需完全排序，只需定位到目标元素
    int qsort(vector<int>& nums, int l, int r, int k)
    {
        // 递归终止条件：区间只有一个元素，该元素就是目标元素
        if (l == r) return nums[l];

        // 1. 随机选择基准元素（避免有序数组导致的时间复杂度退化）
        int key = getRandom(nums, l, r);

        // 2. 三路划分：将数组分为 <key、==key、>key 三个部分
        // left：<key 区域的右边界（初始为l-1，即无元素）
        // right：>key 区域的左边界（初始为r+1，即无元素）
        // i：当前遍历的指针（从l开始）
        int left = l - 1, right = r + 1, i = l;
        while (i < right)
        {
            if (nums[i] < key) {
                // 当前元素 < 基准：放入<key区域，left右移，i右移
                swap(nums[++left], nums[i++]);
            } else if (nums[i] == key) {
                // 当前元素 == 基准：直接跳过，i右移
                i++;
            } else if (nums[i] > key) {
                // 当前元素 > 基准：放入>key区域，right左移，i不移动（新交换来的元素需重新判断）
                swap(nums[--right], nums[i]);
            }
        }

        // 3. 计算各区域的元素个数，判断目标元素所在区间
        // c：>key 区域的元素个数（第k大的元素优先出现在此区域）
        int c = r - right + 1;
        // b：==key 区域的元素个数
        int b = right - left - 1;
        
        if (c >= k) {
            // 情况1：>key区域的元素数 >=k → 目标在>key区域，递归处理右区间
            return qsort(nums, right, r, k);
        } else if (b + c >= k) {
            // 情况2：>key + ==key区域的元素数 >=k → 目标就是基准元素key
            return key;
        } else {
            // 情况3：目标在<key区域 → 递归处理左区间，且k需要减去>key和==key区域的元素数
            return qsort(nums, l, left, k - b - c);
        }
    }

    // 辅助函数：在nums[left...right]范围内随机选择一个元素作为基准
    int getRandom(vector<int>& nums, int left, int right)
    {
        // 生成[0, right-left]范围内的随机数
        int r = rand();
        // 映射到[left, right]区间，得到随机索引
        int key_idx = r % (right - left + 1) + left;
        // 返回随机索引对应的元素值
        return nums[key_idx];
    }
};
```

**关键代码解释：**
- `getRandom` 函数避免了有序数组（如升序/降序）导致快速选择退化为 O(n²) 时间复杂度的问题，是保证平均 O(n) 时间复杂度的关键。
- 将数组分为 `<key`、`==key`、`>key` 三部分，相比传统快速排序的二路划分，更适合处理有重复元素的场景（如示例2中的重复5、3等），减少递归次数。
- 分治逻辑：
   - 先判断 `>key` 区域的元素数是否≥k：如果是，目标元素在这个区域，递归处理右区间；
   - 如果 `>key + ==key` 区域的元素数≥k：目标元素就是key（因为==key区域的所有元素都是第k大的候选）；
   - 否则，目标元素在 `<key` 区域，递归处理左区间，且k需要减去前两个区域的元素数（因为左区间的元素是更小的，需要重新计算k的相对位置）。

