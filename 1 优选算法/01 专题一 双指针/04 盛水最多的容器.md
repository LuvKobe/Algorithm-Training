### 1. 题目链接

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)


### 2. 解法一：暴力枚举

**算法思路：**

枚举出能构成的所有容器，找出其中容积最⼤的值。

容器容积的计算⽅式：
- 设两指针 `i`、`j`，分别指向⽔槽板的最左端以及最右端，此时容器的宽度为 `j - i`。由于容器的⾼度由两板中的短板决定，因此可得容积公式：
- `v = (j - i) * min(height[i], height[j])`

**算法代码：**
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int ret = 0;
        // 两次 for 枚举出所有可能出现的情况
        for (int i = 0; i < n; i ++)
        {
            for (int j = i + 1; j < n; j ++)
            {
                // 计算容积，找出最大的哪一个
                int v = (j - i) * min(height[i], height[j]);
                ret = max(ret, v);
            }
        }
        return ret;
    }
};
```

### 3. 解法二：双指针

**算法思路：**

设两个指针 `left`、`right` 分别指向容器的左右两个端点，此时容器的容积:
- `v = (right - left) * min(height[right], height[left])`

容器的左边界为 `height[right]`，右边界为 `height[left]`。

为了⽅便叙述，我们假设「左边边界」⼩于「右边边界」。

如果此时我们固定⼀个边界，改变另⼀个边界，⽔的容积会有如下变化形式：
- 容器的宽度⼀定变⼩。
- 由于左边界较⼩，决定了⽔的⾼度。如果改变左边界，新的⽔⾯⾼度不确定，但是⼀定不会超过右边的柱⼦⾼度，因此容器的容积可能会增⼤。
- 如果改变右边界，⽆论右边界移动到哪⾥，新的⽔⾯的⾼度⼀定不会超过左边界，也就是不会超过现在的⽔⾯⾼度，但是由于容器的宽度减⼩，因此容器的容积⼀定会变⼩的。

由此可⻅，左边界和其余边界的组合情况都可以舍去。所以我们可以 `left++` 跳过这个边界，继续去判断下⼀个左右边界。

当我们不断重复上述过程，每次都可以舍去⼤量不必要的枚举过程，直到 `left` 和 `right` 相遇。期间产⽣的所有的容积⾥⾯的最⼤值，就是最终答案。


**算法代码：**
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1, ret = 0;
        while (left < right)
        {
            int v = (right - left) * min(height[left], height[right]);  // 长 * 宽
            ret = max(ret, v);

            // 移动指针
            if (height[left] < height[right])
                left++;
            else 
                right--;
        }
        return ret;
    }
};
```