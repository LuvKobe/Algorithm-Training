
### 1. 题目链接

[202. 快乐数](https://leetcode.cn/problems/happy-number/)

### 2. 题目分析

为了⽅便叙述，将「对于⼀个正整数，每⼀次将该数替换为它每个位置上的数字的平⽅和」这⼀个操作记为 `x` 操作。

题⽬告诉我们，当我们不断重复 `x` 操作的时候，计算⼀定会「死循环」，死的⽅式有两种：
- 情况⼀：⼀直在 `1`中死循环，即 `1 -> 1 -> 1 -> 1 .......`。
- 情况⼆：在历史的数据中死循环，但始终变不到 `1`。

由于上述两种情况只会出现⼀种，因此，只要我们能确定循环是在「情况⼀」中进⾏，还是在「情
况⼆」中进⾏，就能得到结果。

**简单证明：**

a. 经过⼀次变化之后的最⼤值 `9^2 * 10 = 810` (`2^31 - 1 = 2147483647`，选⼀个更⼤的最⼤ `9999999999`)，也就是变化的区间在 `[1, 810]` 之间；

b. 根据「鸽巢原理」，⼀个数变化 `811` 次之后，必然会形成⼀个循环；

c. 因此，变化的过程最终会⾛到⼀个圈⾥⾯，因此可以⽤「快慢指针」来解决。


### 3. 解法（快慢指针）

**算法思路：**

根据上述的题⽬分析，我们可以知道，当重复执⾏ `x` 的时候，数据会陷⼊到⼀个「循环」之中。

⽽「快慢指针」有⼀个特性，就是在⼀个圆圈中，快指针总是会追上慢指针的，也就是说他们总会相遇在⼀个位置上。如果相遇位置的值是 `1`，那么这个数⼀定是快乐数；如果相遇位置不是 `1`的话，那么就不是快乐数。

补充知识：如何求⼀个数 `n` 每个位置上的数字的平⽅和。
- 把数 `n` 每⼀位的数提取出来

循环迭代下⾯步骤：
- `int t = n % 10` 提取个位；
- ` n /= 10` ⼲掉个位；

直到 `n` 的值变为 `0`；

提取每⼀位的时候，⽤⼀个变量 `tmp` 记录这⼀位的平⽅与之前提取位数的平⽅和
- `tmp = tmp + t * t`


### 4. 算法代码

C++ 代码
```cpp
class Solution {
public:
    int bitSum(int n) 
    {
        int sum = 0;
        while (n) 
        {
            int t = n % 10;
            sum += pow(t, 2);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) 
    {
        int slow = n, fast = bitSum(n);
        while (slow != fast)
        {
            slow = bitSum(slow);
            fast = bitSum(bitSum(fast));
        }
        return slow == 1;
    }
};
```



 

