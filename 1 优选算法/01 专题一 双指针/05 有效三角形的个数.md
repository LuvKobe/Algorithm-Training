### 1. 题目链接

[611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)


### 2. 解法一（暴力求解）

**算法思路：**

三层 `for` 循环枚举出所有的三元组，并且判断是否能构成三⻆形。

虽然说是暴⼒求解，但是还是想优化⼀下：

判断三角形的优化：
- 如果能构成三角形，需要满足任意两边之和要大于第三边。但是实际上只需让较小的两条边之和大于第三边即可。
- 因此我们可以先将原数组排序，然后从小到大枚举三元组，一方面省去枚举的数量，另一方面方便判断是否能构成三角形。

**算法代码：**
```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        // 1. 排序
        sort(nums.begin(), nums.end());

        // 2. 从小到大枚举所有的三元组
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j ++)
            {
                for (int k = j + 1; k < n; k ++)
                {
                    // 当最⼩的两个边之和⼤于第三边的时候，统计答案
                    if (nums[i] + nums[j] > nums[k])
                        ret ++;
                }
            }
        }
        return ret;
    }
};
```

### 3. 解法二（排序 + 双指针）

先将数组排序。

根据「解法一」中的优化思想，我们可以固定一个「最长边」，然后在比这条边小的有序数组中找出一个二元组，使这个二元组之和大于这个最长边。由于数组是有序的，我们可以利用「对撞指针」来优化。

设最长边枚举到 `i` 位置，区间 `[left, right]` 是 `i` 位置左边的区间（也就是比它小的区间）：

- 如果 `nums[left] + nums[right] > nums[i]`：
    - 说明 `[left, right - 1]` 区间上的所有元素均可以与 `nums[right]` 构成比`nums[i]` 大的二元组。
    - 满足条件的有 `right - left` 种。
    - 此时 `right` 位置的元素的所有情况相当于全部考虑完毕，`right--`，进入下一轮判断。

- 如果 `nums[left] + nums[right] <= nums[i]` ：
    - 说明 `left` 位置的元素是不可能与 `[left + 1, right]` 位置上的元素构成满足条件的二元组。
    - `left` 位置的元素可以舍去，`left++` 进入下轮循环。


**C++算法代码：**
```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        // 1. 优化
        sort(nums.begin(), nums.end());

        // 2. 利用双指针解决问题
        int ret = 0, n = nums.size();
        for (int i = n - 1; i >= 2; i --) // 先固定最大的数
        {
            // 利用双指针快速统计符合要求的三元组的个数
            int left = 0, right = i - 1;
            while (left < right)
            {
                if (nums[left] + nums[right] > nums[i])
                {
                    ret += right - left;
                    right--;
                }
                else 
                {
                    left++;
                }
            }
        }
        return ret;
    }
};
```

