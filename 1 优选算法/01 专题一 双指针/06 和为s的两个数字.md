### 1. 题目链接

[LCR 179. 查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)


### 2. 解法一（暴力枚举）

**算法思路：**

两层 `for` 循环列出所有两个数字的组合，判断是否等于目标值。

**算法流程：**

两层 `for` 循环：
- 外层 `for` 循环依次枚举第一个数 `a`；
内层 `for` 循环依次枚举第二个数 `b`，让它与 `a` 匹配；
    - ps：这里有个魔鬼细节：我们挑选第二个数的时候，可以不从第一个数开始选，因为 `a` 前面的数我们都已经在之前考虑过了；因此，我们可以从 `a` 往后的数开始列举。
- 然后将挑选的两个数相加，判断是否符合目标值。


**算法代码：**
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& price, int target) {
        int n = price.size();
        for (int i = 0; i < n; i ++)    // 第⼀层循环从前往后列举第⼀个数
        {
            for (int j = i + 1; j < n; j ++)    // 第⼆层循环从i位置之后列举第⼆个数
            {
                if (target == price[i] + price[j])  // 两个数的和等于⽬标值，说明我们已经找到结果了
                {
                    return {price[i], price[j]};
                }
            }
        }
        return {-1, -1};
    }
};
```

### 3. 解法二（双指针）

**算法思路：**

注意到本题是升序的数组，因此可以用「对撞指针」优化时间复杂度。

**算法流程（附带算法分析，为什么可以使用对撞指针）：**

初始化 `lfet`，`right` 分别指向数组的左右两端（这里不是我们理解的指针，而是数组的下标）

当 `left < right` 的时候，一直循环
- 当 `nums[left] + nums[right] == target` 时，说明找到结果，记录结果，并且返回；
- 当 `nums[left] + nums[right] < target` 时：
    - 对于 `nums[left]` 而言，此时 `nums[right]` 相当于是 `nums[left]` 能碰到的最大值（别忘了，这里是升序数组哈~）。如果此时不符合要求，说明在这个数组里面，没有别的数符合 `nums[left]` 的要求了（最大的数都满足不了你，你已经没救了）。因此，我们可以大胆舍去这个数，让 `left++` ，去比较下一组数据； 
    - 那对于 `nums[right]` 而言，由于此时两数之和是小于目标值的，`nums[right]` 还可以选择比 `nums[left]` 大的值继续努力达到目标值，因此 `right` 指针我们按兵不动；
- 当 `nums[left] + nums[right] > target` 时，同理我们可以舍去 `nums[right]`（最小的数都满足不了你，你也没救了）。让 `right--`，继续比较下一组数据，而 `left` 指针不变（因为它还是可以去匹配比 `nums[right]` 更小的数的）。


**C++算法代码：**
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& price, int target) {
        int n = price.size();
        int left = 0, right = n - 1, sum = 0;
        while (left < right)
        {
            int sum = price[left] + price[right];
            if (sum > target)
                right--;
            else if (sum < target)
                left++;
            else 
                return  {price[left], price[right]}; // 大括号初始化列表
        }
        return {-1, -1};
    }
};
```