### 1. 题目链接

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)


### 2. 解法（二分查找算法）

**算法思路：**

a. 分析插入位置左右两侧区间上元素的特点：

- 设插入位置的坐标为 `index`，根据插入位置的特点可以知道：
- `[left, index - 1]` 内的所有元素均是小于 `target` 的；
- `[index, right]` 内的所有元素均是大于等于 `target` 的。

b. 设 `left` 为本轮查询的左边界，`right` 为本轮查询的右边界。根据 `mid` 位置元素的信息，分析下一轮查询的区间：
- 当 `nums[mid] >= target` 时，说明 `mid` 落在了 `[index, right]` 区间上，`mid` 左边包括 `mid` 本身，可能是最终结果，所以我们接下来查找的区间在 `[left, mid]` 上。因此，更新 `right` 到 `mid` 位置，继续查找。
- 当 `nums[mid] < target` 时，说明 `mid` 落在了 `[left, index - 1]` 区间上，`mid` 右边但不包括 `mid` 本身，可能是最终结果，所以我们接下来查找的区间在 `[mid + 1, right]` 上。因此，更新 `left` 到 `mid + 1` 的位置，继续查找。

c. 直到我们的查找区间的长度变为 `1`，也就是 `left == right` 的时候，`left` 或者 `right` 所在的位置就是我们要找的结果。


**如下图所示：**

![Alt text](./04%20image/image.png)


**算法代码：**
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1;  // 将左边界移到 mid + 1，排除掉比 target 小的部分
            else if (nums[mid] >= target)
                right = mid;  // 将右边界移到 mid，排除掉比 target 大的部分
        }
        // 当循环结束
        if (nums[left] < target) 
            return left + 1;  // 如果 left 指向的元素小于 target，意味着 target 应该插入到 left 后面的位置
        else 
            return left;  // 否则，返回 left 作为目标值应该插入的位置
    }
};

```