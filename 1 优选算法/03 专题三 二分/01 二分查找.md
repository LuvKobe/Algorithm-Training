### 1. 题目链接

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/)


### 2. 算法流程

- 定义 `left`，`right` 指针，分别指向数组的左右区间。

- 找到待查找区间的中间点 `mid`，找到之后分三种情况讨论：
    - `arr[mid] == target` 说明正好找到，返回 `mid` 的值；
    - `arr[mid] > target` 说明 `[mid, right]` 这段区间都是大于 `target` 的，因此舍去右边区间，在左边 `[left, mid - 1]` 的区间继续查找，即让 `right = mid - 1`，然后重复 2 过程；
    - `arr[mid] < target` 说明 `[left, mid]` 这段区间的值都是小于 `target` 的，因此舍去左边区间，在右边 `[mid + 1, right]` 区间继续查找，即让 `left = mid + 1`，然后重复 2 过程；

- 当 `left` 与 `right` 错开时，说明整个区间都没有这个数，返回 `-1`。

**如下图所示：**

![Alt text](./01%20image/image.png)


**细节问题：**

![Alt text](./01%20image/image-1.png)



**算法代码：**
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 初始化 left 与 right 指针
        int left = 0, right = nums.size() - 1;

        // 由于两个指针相交时，当前元素还未判断，因此需要取等号
        while (left <= right)
        {
            // 先找到区间的中间元素
            int mid = left + (right - left) / 2; // 防止溢出

            // 分三种情况讨论
            if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
            else    
                return mid;
        }
        // 如果程序走到这里，说明没有找到目标值，返回-1
        return -1;
    }
};
```


### 3. 朴素二分模板

![Alt text](./01%20image/image-2.png)