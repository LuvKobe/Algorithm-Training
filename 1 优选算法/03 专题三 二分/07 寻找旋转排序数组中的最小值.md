### 1. 题目链接

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

关于暴力查找，只需遍历一遍数组，这里不再赘述。

### 2. 解法（二分查找）

**算法思路：**

题目中的数组规则如下图所示：

![Alt text](./07%20image/image.png)


其中 `C` 点就是我们要求的点。

二分的本质：找到一个判断标准，使得查找区间能够一分为二。

通过图像我们可以发现，`[A，B]` 区间内的点都是严格大于 `D` 点的值的，`C` 点的值是严格小于 `D` 点的值的。但是当 `[C，D]` 区间只有一个元素的时候，`C` 点的值是可能等于 `D` 点的值的。

因此，初始化左右两个指针 `left`，`right`：

然后根据 `mid` 的落点，我们可以这样划分下一次查询的区间：
- 当 `mid` 在 `[A，B]` 区间的时候，也就是 `mid` 位置的值严格大于 `D` 点的值，下一次查询区间在 `[mid + 1，right]` 上；
- 当 `mid` 在 `[C，D]` 区间的时候，也就是 `mid` 位置的值严格小于等于 `D` 点的值，下次查询区间在 `[left，mid]` 上。

当区间长度变成 `1` 的时候，就是我们要找的结果。

**如下图所示：**

![Alt text](./07%20image/image-1.png)

**算法代码：**
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = n - 1;

        // 二分查找：不断缩小最小值所在的区间
        while (left < right) {
            // 取中点，防止 (left + right) 溢出
            int mid = left + (right - left) / 2;

            // 本题关键点：
            // 将 nums[mid] 与数组最后一个元素 nums[n - 1] 比较
            // 因为旋转数组中，最后一个元素一定属于“右侧有序段”

            // 情况 1：nums[mid] > nums[n - 1]
            // 说明 mid 位于“左侧递增段”
            // 最小值一定在 mid 右边
            if (nums[mid] > nums[n - 1]) {
                left = mid + 1;
            }
            // 情况 2：nums[mid] < nums[n - 1]
            // 说明 mid 位于“右侧递增段”（包含最小值）
            // 最小值可能就是 mid，或者在 mid 左边
            else if (nums[mid] < nums[n - 1]) {
                right = mid;
            }
            // 题目保证元素互不相同
            // 理论上不会出现 nums[mid] == nums[n - 1] 的情况
            else {
                break;
            }
        }

        // 循环结束时，left 指向最小元素的位置
        return nums[left];
    }
};
```