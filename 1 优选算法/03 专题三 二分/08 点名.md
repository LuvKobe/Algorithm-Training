### 1. 题目链接

[LCR 173. 点名](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)


### 2. 解法（二分查找算法）

**算法思路：**
关于这道题中，时间复杂度为 `O(N)` 的解法有很多种，而且也是比较好想的，这里就不再赘述。本题只讲解一个最优的二分法，来解决这个问题。


在这个升序的数组中，我们发现：
- 在第一个缺失位置的左边，数组内的元素都是与数组的下标相等的；
- 在第一个缺失位置的右边，数组内的元素与数组下标是不相等的。

因此，我们可以利用这个「二段性」，来使用「二分查找」算法。


**如下图所示：**

![Alt text](image.png)


**算法代码：**
```cpp
class Solution {
public:
    int takeAttendance(vector<int>& records) {
        int n = records.size();
        int left = 0, right = n - 1;

        // 二分查找：寻找第一个 records[i] != i 的位置
        while (left < right) {
            int mid = left + (right - left) / 2;

            // 若 records[mid] == mid
            // 说明 0 ~ mid 位置都没有缺席同学
            // 缺失学号一定在右半区间
            if (records[mid] == mid) {
                left = mid + 1;
            }
            // 若 records[mid] != mid
            // 说明从 mid 开始已经出现“错位”
            // 缺失学号在左半区间（包含 mid）
            else if (records[mid] != mid) {
                right = mid;
            }
            // 本题保证只缺一人，且 records 单调递增
            // 实际不会进入这里
            else {
                break;
            }
        }

        // 循环结束时，left 指向“第一个可能缺失的位置”
        //
        // 情况 1：
        //   records[left] != left
        //   说明在 left 位置已经发生错位
        //   缺失的学号就是 left
        //
        // 情况 2（关键）：
        //   records[left] == left
        //   说明 0 ~ left 全部连续，没有任何缺失
        //   那么只能是最后一个学号缺失
        //   即缺失的是 left + 1
        return left == records[left] ? left + 1 : left;
    }
};
```