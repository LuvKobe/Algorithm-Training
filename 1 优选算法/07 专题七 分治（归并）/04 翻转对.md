### 1. 题目链接

[493. 翻转对](https://leetcode.cn/problems/reverse-pairs/description/)


**如下图所示：**

![Alt text](./04%20image/image.png)


### 2. 题目解析

翻转对和逆序对的定义大同小异，逆序对是前面的数要大于后面的数。而翻转对是前面的一个数要大于后面某个数的两倍。因此，我们依旧可以用归并排序的思想来解决这个问题。

**如下图所示：**

![Alt text](./04%20image/image-1.png)



### 3. 解法（归并排序）


**算法思路：**

- 大思路与求逆序对的思路一样，就是利用归并排序的思想，将求整个数组的翻转对的数量，转换成三部分：左半区间翻转对的数量，右半区间翻转对的数量，一左一右选择时翻转对的数量。重点就是在合并区间过程中，如何计算出翻转对的数量。

- 与上个问题不同的是，上一道题我们可以一边合并一边计算，但是这道题要求的是左边元素大于右边元素的两倍，如果我们直接合并的话，是无法快速计算出翻转对的数量的。

例如 `left = [4,5,6]`，`right = [3,4,5]` 时，如果是归并排序的话，我们需要计算 left 数组中有多少个能与 right 数组中的 3 组成翻转对。但是我们要遍历到最后一个元素 6 才能确定，时间复杂度较高。

因此我们需要在归并排序之前完成翻转对的统计。


**下面依旧以一个示例来模仿两个有序序列如何快速求出翻转对的过程：**

假定已经有两个已经有序的序列 `left = [4,5,6]`，`right = [1,2,3]`。用两个指针 cur1 cur2 遍历两个数组。

- 对于任意给定的 `left[cur1]` 而言，我们不断地向右移动 `cur2`，直到 `left[cur1] <= 2 * right[cur2]`。此时对于 `right` 数组而言，cur2 之前的元素全部都可以与 left[cur1] 构成翻转对。
- 随后，我们再将 `cur1` 向右移动一个单位，此时 `cur2` 指针并不需要回退（因为 left 数组是升序的）依旧往右移动直到 `left[cur1] <= 2 * right[cur2]`。不断重复这样的过程，就能够求出所有左右端点分别位于两个子数组的翻转对数目。

由于两个指针最后都是不回退的的扫描到数组的结尾，因此两个有序序列求出翻转对的时间复杂度是 O(N)。

综上所述，我们可以利用归并排序的过程，将求一个数组的翻转对转换成求【左数组的翻转对数量 + 右数组中翻转对的数量 + 左右数组合并时翻转对的数量】。


### 4. 方法一：数组降序版本

**如下图所示：**

![Alt text](image-2.png)


**算法代码：**
```cpp
class Solution 
{
    // 辅助数组，用于归并排序时临时存储合并后的结果，避免频繁创建数组
    int tmp[50010];
public:
    // 主函数：计算数组中的重要翻转对数量
    int reversePairs(vector<int>& nums) 
    {
        int n = nums.size();
        // 调用归并排序函数，从整个数组的范围[0, n-1]开始计算
        return mergeSort(nums, 0, n - 1);
    }

    // 归并排序核心函数：同时计算翻转对数量，并对数组区间[left, right]进行排序
    // 返回值：区间[left, right]内的重要翻转对数量
    int mergeSort(vector<int>& nums, int left, int right)
    {
        // 递归终止条件：区间只有一个元素或无元素，没有翻转对
        if (left >= right) return 0;

        int ret = 0; // 存储当前区间的翻转对总数

        // 1. 划分区间：将当前区间拆分为左右两部分
        // [left, mid] 为左区间，[mid + 1, right] 为右区间
        int mid = (left + right) >> 1; // 等价于 (left + right) / 2，位运算更高效

        // 2. 递归计算左右子区间各自的翻转对数量，并累加
        ret += mergeSort(nums, left, mid);   // 左区间翻转对数量
        ret += mergeSort(nums, mid + 1, right); // 右区间翻转对数量

        // 3. 计算跨左右区间的翻转对数量（核心逻辑）
        // 此时左右子区间已分别有序（降序），可以高效统计满足 nums[i] > 2*nums[j] 的(i,j)对
        int cur1 = left, cur2 = mid + 1, i = 0;
        while (cur1 <= mid) // 遍历左区间的每个元素nums[cur1]
        {
            // 找到右区间中第一个满足 nums[cur2] < nums[cur1]/2.0 的位置
            // 注意：不用 nums[cur2]*2 >= nums[cur1] 是避免整数溢出（如nums[cur2]是大数时，乘2会超出int范围）
            // 转换为除法 nums[cur2] >= nums[cur1]/2.0 更安全
            while (cur2 <= right && nums[cur2] >= nums[cur1] / 2.0) cur2++;
            // 如果cur2超出右区间，说明当前左元素没有满足条件的右元素，直接退出
            if (cur2 > right) break;
            // 从cur2到right的所有右元素都满足 nums[cur1] > 2*nums[cur2]，数量为 right - cur2 + 1
            ret += right - cur2 + 1;
            cur1++; // 处理左区间下一个元素
        }

        // 4. 归并操作：将两个有序的子区间（降序）合并为一个有序区间
        cur1 = left, cur2 = mid + 1, i = 0; // 重置指针，cur1指向左区间起点，cur2指向右区间起点
        while (cur1 <= mid && cur2 <= right)
        {
            // 降序合并：将较大的元素优先放入临时数组tmp
            tmp[i++] = nums[cur1] <= nums[cur2] ? nums[cur2++] : nums[cur1++];
        }

        // 5. 处理剩余元素：左区间或右区间可能还有未合并的元素
        while (cur1 <= mid) tmp[i++] = nums[cur1++]; // 左区间剩余元素
        while (cur2 <= right) tmp[i++] = nums[cur2++]; // 右区间剩余元素
        
        // 6. 将临时数组中的有序结果还原到原数组nums的[left, right]区间
        for (int j = left; j <= right; j ++)
        {
            nums[j] = tmp[j - left]; // tmp的索引从0开始，对应nums的left开始的位置
        }

        // 返回当前区间的总翻转对数量（左+右+跨区间）
        return ret;
    }
};
```

**总结：**
- 利用归并排序的分治思想，将问题拆分为「左区间翻转对」「右区间翻转对」「跨区间翻转对」三部分，避免暴力枚举的O(n²)复杂度，最终时间复杂度为O(n log n)。
- 将判断条件 `nums[i] > 2*nums[j]` 转换为 `nums[j] < nums[i]/2.0`，避免整数乘2导致的溢出问题。
- 排序后可以在O(n)时间内统计跨区间的翻转对（利用有序性，右区间满足条件的元素是连续的），同时归并操作保证了后续递归的有序性。


### 5. 方法二：数组升序版

**如下图所示：**

![Alt text](image-3.png)


**算法代码：**
```cpp
class Solution 
{
    // 辅助数组：归并排序时临时存储合并后的升序结果，避免频繁创建数组，提升效率
    int tmp[50010];
public:
    // 主函数：计算数组中满足条件的重要翻转对总数
    int reversePairs(vector<int>& nums) 
    {
        int n = nums.size();
        // 调用归并排序函数，从整个数组的区间[0, n-1]开始递归处理
        return mergeSort(nums, 0, n - 1);
    }

    // 归并排序核心函数：
    // 1. 递归拆分区间并统计各区间内的翻转对数量
    // 2. 合并两个升序子区间为一个升序区间
    // 返回值：当前区间[left, right]内的重要翻转对总数
    int mergeSort(vector<int>& nums, int left, int right)
    {
        // 递归终止条件：区间只有1个元素或无元素，无翻转对（i<j不成立）
        if (left >= right) return 0;

        int ret = 0; // 存储当前区间的翻转对总数（左区间+右区间+跨区间）

        // 1. 划分区间：将[left, right]拆分为左右两个子区间
        // [left, mid] 左区间，[mid+1, right] 右区间
        int mid = (left + right) >> 1; // 等价于 (left+right)/2，位运算更高效

        // 2. 递归计算左右子区间各自的翻转对数量，并累加到总结果
        ret += mergeSort(nums, left, mid);   // 左区间翻转对数量
        ret += mergeSort(nums, mid + 1, right); // 右区间翻转对数量

        // 3. 计算「跨左右区间」的翻转对数量（核心逻辑，升序场景）
        // 此时左右子区间已分别按升序排列，可高效统计满足 nums[i]>2*nums[j] (i在左、j在右) 的对数
        int cur1 = left, cur2 = mid + 1, i = 0;
        while (cur2 <= right) // 遍历右区间的每个元素nums[cur2]（j的位置）
        {
            // 找到左区间中第一个满足 nums[cur1]/2.0 > nums[cur2] 的位置
            // 等价于 nums[cur1] > 2*nums[cur2]，用除法避免整数溢出
            // 因为左区间升序，cur1之后的所有元素都满足 nums[cur1'] > 2*nums[cur2]
            while (cur1 <= mid && nums[cur1] / 2.0 <= nums[cur2]) cur1++;
            // 如果cur1超出左区间，说明当前右元素没有满足条件的左元素，直接退出
            if (cur1 > mid) break;
            // 左区间中从cur1到mid的所有元素都满足条件，数量为 mid - cur1 + 1
            ret += mid - cur1 + 1;
            cur2++; // 处理右区间下一个元素
        }

        // 4. 归并操作：将两个升序的子区间合并为一个升序区间
        cur1 = left, cur2 = mid + 1, i = 0; // 重置指针，指向两个子区间的起点
        while (cur1 <= mid && cur2 <= right)
        {
            // 升序合并：将较小的元素优先放入临时数组tmp
            tmp[i++] = nums[cur1] <= nums[cur2] ? nums[cur1++] : nums[cur2++];
        }

        // 5. 处理剩余元素：左/右子区间可能有未合并完的元素（升序剩余元素直接追加）
        while (cur1 <= mid) tmp[i++] = nums[cur1++]; // 左区间剩余元素
        while (cur2 <= right) tmp[i++] = nums[cur2++]; // 右区间剩余元素
        
        // 6. 将临时数组中的升序结果还原到原数组的[left, right]区间
        for (int j = left; j <= right; j ++)
        {
            // tmp数组从0开始，对应原数组left的位置，因此索引偏移为 j - left
            nums[j] = tmp[j - left];
        }

        // 返回当前区间的总翻转对数量
        return ret;
    }
};
```

**总结：**
- 统计跨区间翻转对时，**遍历右区间元素（j）**，在升序的左区间中找到第一个满足 `nums[i] > 2*nums[j]` 的位置，该位置到左区间末尾的所有元素都满足条件，无需重复遍历。
- 始终用 `nums[cur1]/2.0 > nums[cur2]` 替代 `nums[cur1] > 2*nums[cur2]`，避免整数乘2溢出。
- 将子区间排序为升序，保证统计跨区间翻转对时只需线性遍历（O(n)），整体时间复杂度为O(n log n)，远优于暴力枚举的O(n²)。