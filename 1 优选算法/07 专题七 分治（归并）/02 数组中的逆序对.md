### 1. 题目链接

[LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)


**如下图所示：**

![Alt text](./02%20image/image.png)


### 2. 解法（利用归并排序的过程 —— 分治）

**算法思路：**

- 用归并排序求逆序数是很经典的方法，主要就是在归并排序的合并过程中统计出逆序对的数量，也就是在合并两个有序序列的过程中，能够快速求出逆序对的数量。

- 我们将这个问题分解成几个小问题，逐一破解这道题。

**如下图所示：**

![Alt text](./02%20image/image-1.png)

**注意**：默认都是升序，如果掌握升序的话，降序的归并过程也是可以解决问题的。

**a、先解决第一个问题，为什么可以利用归并排序？**

如果我们将数组从中间划分成两个部分，那么我们可以将逆序对产生的方式划分成三组：
  - 逆序对中两个元素：全部从左数组中选择；
  - 逆序对中两个元素：全部从右数组中选择；
  - 逆序对中两个元素：一个选左数组另一个选右数组。

根据排列组合的分类相加原理，三种情况下产生的逆序对的总和，正好等于总的逆序对数量。

而这个思路正好匹配归并排序的过程：
  - 先排序左数组；
  - 再排序右数组；
  - 左数组和右数组合二为一。


因此，我们可以利用归并排序的过程，先求出左半数组中逆序对的数量，再求出右半数组中逆序对的数量，最后求出一个选择左边，另一个选择右边情况下逆序对的数量，三者相加即可。


**b、解决第二个问题，为什么要这么做？**

在归并排序合并的过程中，我们得到的是两个有序的数组。我们是可以利用数组的有序性，快速统计出逆序对的数量，而不是将所有情况都枚举出来。

最核心的问题，如何在合并两个有序数组的过程中，统计出逆序对的数量？

合并两个有序序列时求逆序对的方法有两种：
- 快速统计出某个数前面有多少个数比它大；
- 快速统计出某个数后面有多少个数比它小；


### 3. 快速统计出某个数前面有多少个数比它大（方法一）

通过一个示例来演示方法一：

假定已经有两个已经有序的序列以及辅助数组 `left = [5, 7, 9]` `right = [4, 5, 8]` `help = []`，通过合并两个有序数组的过程，来求得逆序对的数量：

规定如下定义来叙述过程：
- `cur1` 遍历 `left` 数组，`cur2` 遍历 `right` 数组；
- `ret` 记录逆序对的数量；

#### 第一轮循环:

`left[cur1] > right[cur2]`，由于两个数组都是升序的，那么我们可以断定，此刻 `left` 数组中 `[cur1, 2]` 区间内的3个元素均可与 `right[cur2]` 的元素构成逆序对，因此可以累加逆序对的数量 `ret += 3`，并且将 `right[cur2]` 加入到辅助数组中，`cur2++` 遍历下一个元素。

第一轮循环结束后：`left = [5, 7, 9]` `right = [x, 5, 8]` `help = [4]` `ret = 3` `cur1 = 0` `cur2 = 1`

#### 第二轮循环:

`left[cur1] == right[cur2]`，因为 `right[cur2]` 可能与 `left` 数组中往后的元素构成逆序对，因此我们需要将 `left[cur1]` 加入到辅助数组中去，此时没有产生逆序对，不更新 `ret`。

第二轮循环结束后: `left = [x, 7, 9]` `right = [x, 5, 8]` `help = [4, 5]` `ret = 3` `cur1 = 1` `cur2 = 1`

#### 第三轮循环:

`left[cur1] > right[cur2]`，与第一轮循环相同，此刻 `left` 数组中`[cur1, 2]`区间内的2个元素均可与 `right[cur2]` 的元素构成逆序对，更新 `ret` 的值为 `ret += 2`，并且将 `right[cur2]` 加入到辅助数组中去，`cur2++` 遍历下一个元素。

第三轮循环结束后: `left = [x, 7, 9]` `right = [x, x, 8]` `help = [4, 5, 5]` `ret = 5` `cur1 = 1` `cur2 = 2`

#### 第四轮循环:

`left[cur1] < right[cur2]`，由于两个数组都是升序的，因此我们可以确定 `left[cur1]` 比 `right` 数组中的所有元素都要小。`left[cur1]` 这个元素是不可能与 `right` 数组中的元素构成逆序对。因此，大胆的将`left[cur1]` 这个元素加入到辅助数组中去，不更细 `ret` 的值。

第四轮循环结束后: `left = [x, x, 9]` `right = [x, x, 8]` `help = [4, 5, 5, 7]` `ret = 5` `cur1 = 2` `cur2 = 2`

#### 第五轮循环:

`left[cur1] > right[cur2]`，与第一、第三轮循环相同。此时 `left` 数组内的1个元素能与`right[cur2]`构成逆序对，更新 `ret` 的值，并且将 `right[cur2]` 加入到辅助数组中去。

第五轮循环结束后: `left = [x, x, 9]` `right = [x, x, x]` `help = [4, 5, 5, 7, 8]` `ret = 6` `cur1 = 2` `cur2 = 2`


#### 处理剩余元素:
- 如果是左边出现剩余，说明左边剩下的所有元素都是比右边元素大的，但是它们都是已经被计算过的（我们以右边的元素为基准的），因此不会产生逆序对，仅需归并排序即可。
- 如果是右边出现剩余，说明右边剩下的元素都是比左边大的，不符合逆序对的定义，因此也不需要处理，仅需归并排序即可。

整个过程只需将两个数组遍历一遍即可，时间复杂度为 **O(N)**。

由上述过程我们可以得出方法一统计逆序对的关键点:

- 在合并有序数组的时候，遇到左数组当前元素 > 右数组当前元素时，我们可以通过计算左数组中剩余元素的长度，就可快速求出右数组当前元素前面有多少个数比它大，对比一个一个枚举逆序对效率快了许多。


#### 如下图所示

![Alt text](image-2.png)


#### 方法一：算法代码

```cpp
class Solution {
    int tmp[50010];
public:
    int reversePairs(vector<int>& nums) 
    {
        return mergeSort(nums, 0, nums.size() - 1);
    }

    int mergeSort(vector<int>& nums, int left, int right)
    {
        // 边界情况
        if (left >= right) return 0;

        // 1. 找中间点，将数组分成两部分
        // [left, mid] [mid + 1, right]
        int mid = (left + right) >> 1;

        // 2. 左边逆序对的个数 + 左排序 + 右边逆序对的个数 + 右排序
        int ret = 0;
        ret += mergeSort(nums, left, mid);
        ret += mergeSort(nums, mid + 1, right);

        // 3. 一左一右的个数（升序策略）
        int cur1 = left;
        int cur2 = mid + 1;
        int i = 0;
        while (cur1 <= mid && cur2 <= right)
        {
            if (nums[cur1] <= nums[cur2])
            {
                tmp[i++] = nums[cur1++];
            }
            else if (nums[cur1] > nums[cur2])
            {
                ret += mid - cur1 + 1;
                tmp[i++] = nums[cur2++];
            }
        }

        // 4. 处理剩下的排序逻辑
        while (cur1 <= mid) tmp[i++] = nums[cur1++];
        while (cur2 <= right) tmp[i++] = nums[cur2++];
        for (int j = left; j <= right; j ++)
            nums[j] = tmp[j - left];

        // 5. 返回逆序对的个数
        return ret;
    }
};
```


### 4. 快速统计出某个数后面有多少个数比它小（方法二）

依旧通过一个示例来演示方法二：

假定已经有两个已经有序的序列以及辅助数组 `left = [5, 7, 9]` `right = [4, 5, 8]` `help = []`，通过合并两个有序数组的过程，来求得逆序对的数量：

规定如下定义来叙述过程：

- `cur1` 遍历 `left` 数组，`cur2` 遍历 `right` 数组
- `ret` 记录逆序对的数量


#### 第一轮循环:

`left[cur1] > right[cur2]`，先不要着急统计，因为我们要找的是当前元素后面有多少比它小的，这里虽然出现了一个，但是 `right` 数组中依旧还可能有其余比它小的。因此此时仅将 `right[cur2]` 加入到辅助数组中去，并且将 `cur2++`。

第一轮循环结束后: `left = [5, 7, 9]` `right = [x, 5, 8]` `help = [4]` `ret = 0` `cur1 = 0` `cur2 = 1`

#### 第二轮循环:

`left[cur1] == right[cur2]`，由于两个数组都是升序，这个时候对于元素 `left[cur1]` 来说，我们已经可以断定 `right` 数组中 `[0, cur2)` 左闭右开区间上的元素都是比它小的。因此此时可以统计逆序对的数量 `ret += cur2 - 0`，并且将 `left[cur1]` 放入辅助数组中去，`cur1++` 遍历下一个元素。

第二轮循环结束后: `left = [x, 7, 9]` `right = [x, 5, 8]` `help = [4, 5]` `ret = 1` `cur1 = 1` `cur2 = 1`

#### 第三轮循环:

`left[cur1] > right[cur2]`，与第一轮循环相同，直接将 `right[cur2]` 加入到辅助数组中去，`cur2++` 遍历下一个元素。

第三轮循环结束后: `left = [x, 7, 9]` `right = [x, x, 8]` `help = [4, 5, 5]` `ret = 1` `cur1 = 1` `cur2 = 2`

#### 第四轮循环:

`left[cur1] < right[cur2]`，由于两个数组都是升序的，这个时候对于元素 `left[cur1]` 来说，我们依旧已经可以断定 `right` 数组中 `[0, cur2)` 左闭右开区间上的元素都是比它小的。因此此时可以统计逆序对的数量 `ret += cur2 - 0`，并且将 `left[cur1]` 放入到辅助数组中去，`cur1++` 遍历下一个元素。

第四轮循环结束后: `left = [9]` `right = [8]` `help = [4, 5, 5, 7]` `ret = 3` `cur1 = 2` `cur2 = 2`

#### 第五轮循环:

`left[cur1] > right[cur2]`，与第一、第三轮循环相同。直接将 `right[cur2]` 加入到辅助数组中去，`cur2++` 遍历下一个元素。

第五轮循环结束后: `left = [x, x, 9]` `right = [x, x, x]` `help = [4, 5, 5, 7, 8]` `ret = 3` `cur1 = 2` `cur2 = 2`


#### 处理剩余元素:

- 如果是左边出现剩余，说明左边剩下的所有元素都是比右边元素大的，但是相比较于方法一，逆序对的数量是没有统计过的。因此，我们需要统计 `ret` 的值：
  - 设左边数组剩余元素的个数为 `leave`
  - `ret += leave * (cur2 - 0)`

- 对于本题来说，处理剩余元素的时候，`left` 数组剩余1个元素，`cur2 - 0 = 3`，因此 `ret` 需要类加上3，结果为6。与方法一求得的结果相同。

- 如果是右边出现剩余，说明右边剩下的元素都是比左边大的，不符合逆序对的定义，因此也不需要处理，仅需归并排序即可。


整个过程只需将两个数组遍历一遍即可，时间复杂度依旧为 **O(N)**。

由上述过程我们可以得出方法二统计逆序对的关键点:
- 在合并有序数组的时候，遇到左数组当前元素 <= 右数组当前元素时，我们可以通过计算右数组已经遍历过的元素的长度，快速求出左数组当前元素后面有多少个数比它大。
- 但是需要注意的是，在处理剩余元素的时候，方法二还需要统计逆序对的数量。


#### 如下图所示

![Alt text](image-3.png)


#### 方法二：算法代码

```cpp
class Solution {
    int tmp[50010];
public:
    int reversePairs(vector<int>& nums) 
    {
        return mergeSort(nums, 0, nums.size() - 1);
    }

    int mergeSort(vector<int>& nums, int left, int right)
    {
        // 边界情况
        if (left >= right) return 0;

        // 1. 找中间点，将数组分成两部分
        // [left, mid] [mid + 1, right]
        int mid = (left + right) >> 1;

        // 2. 左边逆序对的个数 + 左排序 + 右边逆序对的个数 + 右排序
        int ret = 0;
        ret += mergeSort(nums, left, mid);
        ret += mergeSort(nums, mid + 1, right);

        // 3. 一左一右的个数（降序策略）
        int cur1 = left;
        int cur2 = mid + 1;
        int i = 0;
        while (cur1 <= mid && cur2 <= right)
        {
            if (nums[cur1] <= nums[cur2])
            {
                tmp[i++] = nums[cur2++];
            }
            else if (nums[cur1] > nums[cur2])
            {
                ret += right - cur2 + 1;
                tmp[i++] = nums[cur1++];
            }
        }

        // 4. 处理剩下的排序逻辑
        while (cur1 <= mid) tmp[i++] = nums[cur1++];
        while (cur2 <= right) tmp[i++] = nums[cur2++];
        for (int j = left; j <= right; j ++)
            nums[j] = tmp[j - left];

        // 5. 返回逆序对的个数
        return ret;
    }
};
```